<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Figma Plugin UI</title>

</head><style>:root {
  --color-bg: #ffffff;
  --color-bg-brand: #0d99ff;
  --color-bg-brand-hover: #007be5;
  --color-bg-brand-pressed: #007be5;
  --color-bg-brand-secondary: #0768cf;
  --color-bg-brand-tertiary: #e5f4ff;

  --color-bg-danger-tertiary: #ffe2e0;
  --color-bg-disabled: #d9d9d9;
  --color-bg-hover: #f5f5f5;
  --color-bg-secondary: #f5f5f5;
  --color-bg-tertiary: #e6e6e6;

  --color-bg-warning-tertiary: #fff1c2;
  --color-border: #e6e6e6;
  --color-border-brand: #bde3ff;
  --color-border-component: #e4ccff;
  --color-border-component-hover: #9747ff;
  --color-border-component-strong: #8638e5;

  --color-text: #000000e5;
  --color-text-brand: #007be5;
  --color-text-disabled: #0000004d;
  --color-text-secondary: #00000080;
  --color-text-onbrand: #ffffff;

  --color-bg-danger: #dc3412;
  --color-border-danger: #dc3412;
  --color-text-danger: #dc3412;

  --color-bg-positive: #b8f8da;
  --color-bg-positive-strong: #009951;
  --color-text-success: #009951;

  --color-text-warning: #b86200;
  --font-family: "Inter", "Helvetica", sans-serif;
  --font-size-small: 10px;
  --font-size-medium: 11px;
  --font-size-big: 13px;
  --font-weight-light: 300;
  --font-weight-regular: 400;
  --font-weight-medium: 600;
  --font-weight-bold: 700;

  --spacing-large: 20px;
  --spacing-medium: 10px;
  --spacing-small: 5px;
  --primary-color: #0078d4;
  --primary-color-hover: #005a9e;
  --background-color: #ffffff;
  --text-color: #333;
  --text-light-color: #666;
  --border-color: #ccc;
  --light-background-color: #eee;
  --gray-color: rgb(187, 187, 205);
  --light-gray-color: rgb(236, 238, 246);
  --red-color: #1e1e1e;
  --blue-color: #18a0fb;
  --violet-color: #85389d;
  --font-normal: 14px;
  --font-small: 12px;
  --font-mini: 10px;
  --hover-color: #f5f5f5;
}

body {
  font-family: var(--font-family);
  font-size: var(--font-size-medium);
  background-color: var(--color-bg);
  margin: 0px;
  padding: 0px;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
}
/* контейнер для контента */
.container {
  display: flex;
  flex-direction: column;
  gap: 0px;
  width: 100%;
  height: 100%;
}

.header {
  height: fit-content;
  padding-bottom: 4px;
  border-bottom: var(--color-border) 1px solid;
}

.tabs-content {
  height: 100%;
  margin: 0px;
  padding: 8px 16px;
  background-color: var(--color-bg);
  overflow-y: scroll;
}

.footer {
  color: var(--color-text-secondary);
  border-top: var(--color-border) 1px solid;
  background-color: var(--color-bg-secondary);
  width: 100%;
  height: 32px;
  display: flex;
  align-items: center;
}

.footer .wrapper {
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  gap: 8px;
  width: 100%;
  padding: 0px 8px;
  align-items: center;
}

.button-wrapper {
  padding: 8px 16px;
  display: flex;
  align-items: center;
  gap: 16px;
  align-content: center;
  border-bottom: var(--color-border) 1px solid;
}

h1 {
  font-size: 18px;
  font-weight: 700;
  margin-bottom: var(--spacing-large);
}

h3 {
  font-size: 14px;
  font-weight: 700;
  margin-bottom: var(--spacing-medium);
}

.todo {
  color: var(--color-text);
}

/* Tabs */
.tabs {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 8px 16px;
}

.tabs.small {
  padding: 0px 10px 4px 16px;
  gap: 2px;
}

.tab {
  padding: 4px 8px;
  border-radius: 12px;
  cursor: pointer;
  color: var(--color-text-brand);
  font-size: var(--font-size-medium);
  font-weight: var(--font-weight-regular);
  border: var(--color-border-brand) 1px solid;
  transition: all 0.2s ease;
  white-space: nowrap;
}

.tab_disabled {
  padding: 4px 8px;
  border-radius: 12px;
  cursor: pointer;
  color: var(--color-text-disabled);
  font-size: var(--font-size-medium);
  font-weight: var(--font-weight-regular);
  border: var(--color-border) 1px solid;
}

.tab_success {
  padding: 4px 8px;
  border-radius: 12px;
  cursor: pointer;
  background-color: var(--color-bg-positive);
  color: var(--color-bg-positive-strong);
  font-size: var(--font-size-medium);
  font-weight: var(--font-weight-regular);
  border: var(--color-bg-positive) 1px solid;
}

.tab:hover {
  background-color: var(--color-bg-brand-tertiary);
  color: var(--color-text-brand);
}

.tab.active {
  background-color: var(--color-bg-brand);
  color: var(--color-text-onbrand);
}

/* Модификатор colors для базового класса tab */
.tab.errors {
  color: var(--color-text-danger);
  border-color: var(--color-text-danger);
  background-color: transparent;
}

.tab.errors:hover {
  background-color: var(--color-bg-danger-tertiary);
  color: var(--color-text-danger);
}

.tab.errors.active {
  background-color: var(--color-text-danger);
  color: white;
}

.tab.colors:disabled,
.tab.colors.disabled {
  color: var(--color-text-disabled);
  border-color: var(--color-text-disabled);
  background-color: transparent;
  cursor: default;
}

/* Стили для дочерних вкладок без рамки */
.tab_borderless {
  padding: 3px 6px;
  border-radius: 12px;
  cursor: pointer;
  color: var(--color-text-danger);
  font-size: var(--font-size-medium);
  font-weight: var(--font-weight-regular);
  border: none;
  background-color: transparent;
  transition: all 0.2s ease;
  white-space: nowrap;
  height: fit-content;
}

.tab_borderless:hover {
  background-color: var(--color-bg-danger-tertiary);
}

.tab_borderless.active {
  background-color: var(--color-bg-danger);
  color: var(--color-text-onbrand);
}

.tab_borderless_disabled {
  padding: 3px 6px;
  border-radius: 12px;
  cursor: default;
  color: var(--color-text-disabled);
  font-size: var(--font-size-medium);
  font-weight: var(--font-weight-regular);
  border: none;
  background-color: transparent;
  white-space: nowrap;
  height: fit-content;
}

/* Стиль для заблокированных вкладок */
.tab_disabled {
  color: var(--color-text-disabled) !important;
  cursor: not-allowed !important;
  pointer-events: none;
}

.tab_success.active {
  background-color: var(--color-bg-positive);
}

.footer .tabs {
  gap: 2px;
  flex-wrap: nowrap;
  width: fit-content;
  margin: 0px;
  padding: 0px 16px;
}

.footer .tab {
  padding-top: 4px;
  font-size: var(--font-size-small);
  font-weight: var(--font-weight-regular);
  color: var(--color-text-secondary);
  cursor: pointer;
  border-radius: 0px;
  border: none;
  background-color: transparent;
  transition: all 0.2s ease;
  padding: 4px;
}

.footer .user-info {
  font-size: var(--font-size-small);
  font-weight: var(--font-weight-regular);
  width: 100%;
  height: fit-content;
}

.footer .tab:hover {
  background-color: transparent;
  color: var(--color-text);
}

.footer .tab.active {
  background-color: var(--color-bg-tertiary);
  font-weight: var(--font-weight-regular);
  color: var(--color-text);
}

.tab-content {
  display: none;
}
.tab-content.active {
  display: block;
}

/* Results and Icons */
#results,
#review,
#icons,
#outdated,
#colors,
#log,
#total,
#lost,
#detached,
#deprecated,
#errorsTab,
#instances {
  font-size: var(--font-size-medium);
  font-weight: var(--font-weight-regular);
  color: var(--color-text);
  overflow-y: auto;
  line-height: 14px;
  padding-bottom: 8px;
}

#results ul,
#review ul,
#icons ul,
#colors ul,
#outdated ul,
#deprecated ul,
#lost ul,
#detached ul,
#log,
#lost ul,
#errorsTab ul {
  gap: 2px;
  margin-top: 0px;
  padding-left: 0px;
}

#results li,
#icons li,
#review li,
#colors li,
#outdated li,
#lost li,
#deprecated li,
#detached li,
#log li {
  margin: 0px;
  padding: 4px 0 0 16px;
  list-style-type: none;
}

.section-header {
  font-size: var(--font-size-big);
  font-weight: var(--font-weight-bold);
  color: var(--color-text);
  margin: 8px 0 4px 0;
}

/* Grouping */
/* Контейнер строки группы */
.group-header {
  font-weight: var(--font-weight-medium);
  cursor: pointer;
  width: 100%;
  padding: 4px 0px;
  display: flex;
  flex-wrap: nowrap;
  flex-direction: row;
  vertical-align: middle;
  line-height: 18px;
  align-items: flex-start; /* Изменено с center на flex-start */
}
/* Контейнер иконки группы */
.group-color-icon {
  width: 16px;
  height: 16px;
  border-radius: 4px;
  margin-right: 4px;
  border: 1px solid #ddd;
  min-width: 16px;
}
/* Контейнер имени группы */
.group-name {
  font-weight: var(--font-weight-medium);
  font-size: var(--font-size-medium);
  width: 100%;
  padding: 1px 0px 0px 2px;
}

.group-counter {
  font-size: var(--font-size-small);
  color: var(--color-text-secondary);
  background-color: var(--color-bg-hover);
  font-weight: var(--font-weight-regular);
  padding: 2px 4px;
  border-radius: 4px;
}

.group-items {
  display: none;
}
.group-items.expanded {
  display: block;
  padding-bottom: 16px;
}

.hidden-label {
  font-size: var(--font-size-medium);
  font-weight: var(--font-weight-light);
  color: var(--color-border-component-strong);
  font-size: var(--font-size-small);
}

.component-link {
  color: var(--color-text);
  text-decoration: none;
}
.component-link:hover {
  color: var(--color-text-brand);
  text-decoration: underline;
}

.component-name-container {
  display: flex;
  align-items: right;
  width: 100%;
  gap: 4px;
  align-items: center;
  padding: 0px;
}

.parent-component-name {
  font-size: var(--font-size-medium);
  font-weight: var(--font-weight-light);
  color: var(--color-text-secondary);
}

.version-tag {
  white-space: nowrap;
  background-color: var(--color-bg-brand-tertiary);
  color: var(--color-text);
  font-size: var(--font-size-small);
  font-weight: var(--font-weight-regular);
  padding: 3px 6px;
  border-radius: 2px;
  font-family: monospace;
  line-height: 12px;
}

.version-tag-outdated {
  background-color: var(--color-bg-danger-tertiary);
  color: var(--color-text-danger);
}

.version-tag-latest {
  background-color: var(--color-bg-positive);
  color: var(--color-text-success);
}

.version-tag-notlatest {
  background-color: var(--color-bg-warning-tertiary);
  color: var(--color-text-warning);
}

.version-group {
  display: flex;
  align-items: right;
  margin-left: auto;
  gap: 2px;
}

/* Debug */
#debug {
  font-size: var(--font-size-medium);
  color: var(--color-text);
  text-align: left;
  overflow-y: auto;
  flex-grow: 1;
  position: relative;
}

#debugContent {
  font-family: monospace;
  font-size: var(--font-size-medium);
  white-space: pre-wrap;
  overflow-x: auto;
}

.debug-tree {
  font-family: monospace;
  font-size: var(--font-size-medium);
  line-height: 1.4;
  padding: 10px;
}

.debug-tree details {
  margin-left: 00px;
}

.debug-tree summary {
  cursor: pointer;
  padding: 4px;
  border-radius: 4px;
  margin-bottom: 4px;
  padding-left: 10px;
}

.debug-tree summary:hover {
  background-color: var(--hover-color);
}

.debug-tree .key {
  color: #905;
  font-weight: bold;
}

.debug-tree .string {
  color: #690;
}

.debug-tree .number {
  color: #2f6f9f;
}

.debug-tree .match {
  background-color: yellow;
  padding: 2px;
}

.search-container {
  padding: 0px 0px;
  display: flex;
  flex-direction: column;
}

#debugSearchInput {
  width: 100%;
  padding: 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  font-size: 14px;
}

#debugContent {
  /* Удален #searchResults, так как элемент отсутствует в HTML */
  font-family: monospace;
  font-size: var(--font-size-medium);
  padding: 10px 00px;
}

.highlight {
  background-color: yellow;
}

.loader-container {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 255, 255, 0.93);
  justify-content: center;
  align-items: center;
  z-index: 1000;
  flex-direction: column;
  padding: 20px;
}

.progress-info {
  font-size: 14px;
  color: var(--color-text);
  text-align: center;
  margin-top: 15px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-width: 200px;
}

.progress-phase {
  color: var(--color-secondary);
  font-weight: var(--font-weight-regular);
  font-size: var(--font-size-small);
  margin-top: 4px;
}

.progress-counts {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 5px;
  font-family: monospace;
  font-size: var(--font-size-medium);
}

.progress-bar {
  width: 100%;
  height: 6px;
  background-color: #eee;
  border-radius: 6px;
  margin-top: 5px;
  overflow: hidden;
}

.progress-bar-fill {
  height: 100%;
  background-color: var(--color-bg-brand);
  width: 0%;
  transition: width 0.3s ease;
}

/* Add styles for collapsible debug view */
.toggle-groups {
  color: var(--color-text-brand);
  font-size: var(--font-size-small);
  flex-direction: row-reverse;
  display: flex;
  text-decoration: none;
  cursor: pointer;
  padding: 4px 0px;
}

.toggle-groups:hover {
  text-decoration: underline;
}

/* Добавляем CSS для ссылки select all в секцию стилей */
.select-all-container {
  display: inline-block;
}

.select-all-link svg {
  width: 18px;
  height: 18px;
  fill: var(--color-bg-brand);
  vertical-align: middle;
}

.select-all-link:hover svg {
  fill: var(--color-bg-brand-hover);
}

/* Добавляем стили для SVG иконки */
.instance-icon,
.info-icon,
.text-icon,
.frame-icon,
.rectangle-icon {
  width: 20px;
  height: 20px;
  margin-right: 0px;
  display: inline-block;
  vertical-align: middle;
  cursor: pointer;
  opacity: 0.9;
  fill: var(--color-border-component-strong);
}

/* Стили для popover — все визуальные параметры вынесены в CSS */
.popover {
  /* Позиционирование: фиксированное относительно окна плагина, координаты задаёт JS */
  position: fixed;
  /* Внешний вид */
  background-color: white;
  border: 1px solid #ccc;
  padding: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  font-size: 12px;
  /* Максимальная ширина popover-а */
  max-width: 500px;
  /* По умолчанию скрыт — видимость контролируется через display в JS */
  display: none;
  /* Высокий z-index, чтобы перекрывать другие элементы интерфейса */
  z-index: 10000;
  /* Обеспечить перенос текста и читаемость */
  word-break: break-word;
}

/* Splash Screen Styles */
.splash-screen {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  width: 100%;
  background-color: white;
  text-align: center;
  overflow: hidden;
}

.splash-image {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: 1;
}

.splash-content {
  position: relative;
  z-index: 2;
  color: white;
  text-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
  bottom: 30px;
  position: absolute;
}

.splash-title {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 16px;
}

.button-main {
  background: var(--color-bg-brand);
  color: var(--color-text-onbrand);
  border: none;
  border-radius: 12px;
  height: 60px;
  padding: 10px 20px;
  cursor: pointer;
  font-size: 20px;
  font-weight: 700;
  transition: background-color 0.3s ease;
}

.button-secondary {
  background-color: var(--color-bg);
  color: var(--color-text);
  border: 1px solid var(--color-border-brand);
  font-size: var(--font-size-big);
  font-weight: var(--font-weight-bold);
  border-radius: 12px;
  height: 60px;
  padding: 10px 20px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

.button-wrapper .button-main {
  padding: 8px 24px;
  height: fit-content;
  border-radius: 5px;
  font-weight: var(--font-weight-regular);
  font-size: var(--font-size-medium);
}

.small-button-wrapper .button-secondary {
  padding: 8px 12px;
  border-radius: 8px;
  font-size: var(--font-size-big);
  font-weight: var(--font-weight-medium);
  height: fit-content;
}

.button-secondary:hover {
  background-color: var(--color-bg-secondary);
}

.button-main:hover {
  background-color: var(--color-bg-brand-hover);
}

.main-content {
  display: none;
  width: 100%;
  height: 100vh;
}

/* Добавляем стили для сообщений об ошибках */
.error-message {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: var(--color-bg);
  color: var(--color-text-danger);
  padding: 20px;
  border-radius: 8px;
  text-align: center;
  z-index: 1000;
  border: 1px solid var(--color-border-danger);
  max-width: 80%;
}

.error-message p {
  margin: 0;
  color: var(--color-color-danger);
  font-size: 14px;
  line-height: 1.4;
}

.resize-handle {
  position: fixed;
  bottom: -8;
  right: -8;
  width: 40px;
  height: 40px;
  cursor: nwse-resize;
  padding: 0px;
  box-sizing: content-box;
}

.resize-handle svg {
  display: block;
  width: 100%;
  height: 100%;
  opacity: 0.3;
  transition: opacity 0.2s;
}

.resize-handle:hover svg {
  opacity: 1;
}

.switch-container {
  display: flex;
  gap: 4px;
  align-items: center;
  font-size: var(--font-size-medium);
  color: var(--color-text-secondary);
  padding-left: 16px;
}

.switch {
  position: relative;
  display: flex;
  width: 34px;
  height: 20px;
}

.switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: 0.4s;
  transition: 0.4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 16px;
  width: 16px;
  left: 2px;
  bottom: 2px;
  background-color: white;
  -webkit-transition: 0.4s;
  transition: 0.4s;
}

input:checked + .slider {
  background-color: #2196f3;
}

input:focus + .slider {
  box-shadow: 0 0 1px #2196f3;
}

input:checked + .slider:before {
  -webkit-transform: translateX(14px);
  -ms-transform: translateX(14px);
  transform: translateX(14px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 20px;
}

.slider.round:before {
  border-radius: 50%;
}

/* Statistics styles */

.stats-list {
  list-style: none;
  width: 200px;
  padding: 0;
  margin: 0;
}

.stats-list li {
  display: flex;
  justify-content: space-between;
  padding: 6px 0;
  border-bottom: 1px dotted var(--color-border);
}

.stats-list li:last-child {
  border-bottom: none;
}

.stats-list .type-name {
  color: var(--color-text);
}

.stats-list .type-count {
  font-weight: var(--font-weight-medium);
}
</style>

<body>

  <!-- resize icon -->
  <div id="resizeHandle" class="resize-handle">
    <svg width="16" height="16">
      <use href="#resize-icon" />
    </svg>
  </div>

  <!-- Splash Screen -->
  <div class="splash-screen" id="splashScreen">
    <img src="" alt="Welcome" class="splash-image" onload="console.log('Изображение успешно загружено')">
    <div class="splash-content">
      <h1 class="splash-title"></h1>
      <button id="startCheck" class="button-main">Deep dive</button>
    </div>
  </div>

  <!-- Main Content -->
  <div class="main-content" id="mainContent">
    <!-- Добавляем SVG-спрайт в начало body -->
    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
      <symbol id="instance-icon" viewBox="0 0 16 16">
        <path fill-rule="evenodd" clip-rule="evenodd"
          d="M7.29289 2.29289C7.68342 1.90237 8.31658 1.90237 8.70711 2.29289L13.7071 7.29289C14.0976 7.68342 14.0976 8.31658 13.7071 8.70711L8.70711 13.7071C8.31658 14.0976 7.68342 14.0976 7.29289 13.7071L2.29289 8.70711C1.90237 8.31658 1.90237 7.68342 2.29289 7.29289L7.29289 2.29289ZM3.70711 8.70711L3 8L3.70711 7.29289L7.29289 3.70711L8 3L8.70711 3.70711L12.2929 7.29289L13 8L12.2929 8.70711L8.70711 12.2929L8 13L7.29289 12.2929L3.70711 8.70711Z" />
      </symbol>
      <symbol id="info-icon" viewBox="0 0 16 16">
        <path fill-rule="evenodd" clip-rule="evenodd"
          d="M13 8C13 10.7614 10.7614 13 8 13C5.23858 13 3 10.7614 3 8C3 5.23858 5.23858 3 8 3C10.7614 3 13 5.23858 13 8ZM14 8C14 11.3137 11.3137 14 8 14C4.68629 14 2 11.3137 2 8C2 4.68629 4.68629 2 8 2C11.3137 2 14 4.68629 14 8ZM7.48297 10.5355C7.48297 10.8195 7.71318 11.0497 7.99717 11.0497C8.28116 11.0497 8.51137 10.8195 8.51137 10.5355V7.20027C8.51137 6.91629 8.28116 6.68607 7.99717 6.68607C7.71318 6.68607 7.48297 6.91629 7.48297 7.20027V10.5355ZM7.57956 5.90482C7.69698 6.01277 7.83713 6.06675 8.00001 6.06675C8.16478 6.06675 8.30493 6.01277 8.42047 5.90482C8.53789 5.79497 8.5966 5.66334 8.5966 5.50993C8.5966 5.35463 8.53789 5.223 8.42047 5.11505C8.30493 5.0052 8.16478 4.95027 8.00001 4.95027C7.83713 4.95027 7.69698 5.0052 7.57956 5.11505C7.46213 5.223 7.40342 5.35463 7.40342 5.50993C7.40342 5.66334 7.46213 5.79497 7.57956 5.90482Z" />
      </symbol>
      <symbol id="frame-icon" viewBox="0 0 16 16">
        <path fill-rule="evenodd" clip-rule="evenodd"
          d="M5.5 3C5.77614 3 6 3.22386 6 3.5V5H10V3.5C10 3.22386 10.2239 3 10.5 3C10.7761 3 11 3.22386 11 3.5V5H12.5C12.7761 5 13 5.22386 13 5.5C13 5.77614 12.7761 6 12.5 6H11V10H12.5C12.7761 10 13 10.2239 13 10.5C13 10.7761 12.7761 11 12.5 11H11V12.5C11 12.7761 10.7761 13 10.5 13C10.2239 13 10 12.7761 10 12.5V11H6V12.5C6 12.7761 5.77614 13 5.5 13C5.22386 13 5 12.7761 5 12.5V11H3.5C3.22386 11 3 10.7761 3 10.5C3 10.2239 3.22386 10 3.5 10H5V6H3.5C3.22386 6 3 5.77614 3 5.5C3 5.22386 3.22386 5 3.5 5H5V3.5C5 3.22386 5.22386 3 5.5 3ZM10 10L10 6H6V10H10Z" />
      </symbol>
      <symbol id="text-icon" viewBox="0 0 16 16">
        <path fill-rule="evenodd" clip-rule="evenodd"
          d="M3 3.5C3 3.22386 3.22386 3 3.5 3H8H12.5C12.7761 3 13 3.22386 13 3.5V5C13 5.27614 12.7761 5.5 12.5 5.5C12.2239 5.5 12 5.27614 12 5V4H8.5V12H9.5C9.77614 12 10 12.2239 10 12.5C10 12.7761 9.77614 13 9.5 13H8H6.5C6.22386 13 6 12.7761 6 12.5C6 12.2239 6.22386 12 6.5 12H7.5V4H4V5C4 5.27614 3.77614 5.5 3.5 5.5C3.22386 5.5 3 5.27614 3 5V3.5Z" />
      </symbol>
      <symbol id="rectangle-icon" viewBox="0 0 16 16">
        <path fill-rule="evenodd" clip-rule="evenodd"
          d="M11.5 4H4.5C4.22386 4 4 4.22386 4 4.5V11.5C4 11.7761 4.22386 12 4.5 12H11.5C11.7761 12 12 11.7761 12 11.5V4.5C12 4.22386 11.7761 4 11.5 4ZM4.5 3C3.67157 3 3 3.67157 3 4.5V11.5C3 12.3284 3.67157 13 4.5 13H11.5C12.3284 13 13 12.3284 13 11.5V4.5C13 3.67157 12.3284 3 11.5 3H4.5Z" />
      </symbol>
      <symbol id="select-all-icon" viewBox="0 0 24 24">
        <path fill-rule="evenodd" clip-rule="evenodd"
          d="M12 18C15.3137 18 18 15.3137 18 12C18 8.68629 15.3137 6 12 6C8.68629 6 6 8.68629 6 12C6 15.3137 8.68629 18 12 18ZM12 19C15.866 19 19 15.866 19 12C19 8.134 15.866 5 12 5C8.134 5 5 8.134 5 12C5 15.866 8.134 19 12 19ZM12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM13 12C13 12.5523 12.5523 13 12 13C11.4477 13 11 12.5523 11 12C11 11.4477 11.4477 11 12 11C12.5523 11 13 11.4477 13 12Z" />
      </symbol>
      <symbol id="resize-icon" viewBox="0 0 24 24">
        <path fill-rule="evenodd" clip-rule="evenodd"
          d="M11.5219 16H11.5H8.5C8.22386 16 8 15.7761 8 15.5C8 15.2239 8.22386 15 8.5 15H11.5C12.2083 15 12.7095 14.9996 13.1013 14.9676C13.4872 14.9361 13.7228 14.8764 13.908 14.782C14.2843 14.5903 14.5903 14.2843 14.782 13.908C14.8764 13.7228 14.9361 13.4872 14.9676 13.1013C14.9996 12.7095 15 12.2083 15 11.5V8.5C15 8.22386 15.22386 8 15.5 8C15.7761 8 16 8.22386 16 8.5V11.5V11.5219C16 12.2034 16 12.7454 15.9643 13.1827C15.9277 13.6305 15.8512 14.0123 15.673 14.362C15.3854 14.9265 14.9265 15.3854 14.362 15.673C15.0123 15.8512 15.6305 15.9277 15.1827 15.9643C12.7454 16 12.2034 16 11.5219 16Z" />
      </symbol>
    </svg>

    <!-- Loader -->
    <div class="loader-container">
      <div class="progress-info">
        <div class="progress-counts">Обработано: <span id="processedCount">0</span> из <span id="totalCount">0</span>
        </div>
        <div class="progress-bar">
          <div class="progress-bar-fill" id="progressBarFill"></div>
        </div>
        <div class="progress-phase" id="progressPhase"></div>
      </div>
    </div>

    <!-- Весь контент -->
    <div class="container">
      <!-- Header -->
      <div class="header">
        <!-- Кнопка -->
        <div class="button-wrapper">
          <button id="checkAll" class="button-main">New search</button>
          <div class="switch-container">
            <label for="showHiddenToggle" class="switch" style="text-decoration: none; cursor: pointer;">
              <input type="checkbox" id="showHiddenToggle" class="checkbox" checked>
              <span class="slider round"></span>
            </label>hidden
          </div>
        </div>
        <!-- Tabs -->
        <div class="tabs">
          <div class="tab" data-tab="instances">All instanses</div>
          <div class="tab errors active" data-tab="errorsTab">Errors</div>
          <!--<div class="tab colors" data-tab="colors">Colors</div>-->
          <div class="tab" data-tab="total">Total</div>
          <!--<div class="tab" data-tab="icons">Icons</div>-->
        </div>
        <div id="subTabs" class="tabs small" style="display: flex;">
          <div class="tab_borderless active" data-tab="review">Review</div>
          <div class="tab_borderless" data-tab="colors">Colors</div>
          <div class="tab_borderless" data-tab="outdated">Outdated</div>
          <div class="tab_borderless" data-tab="lost">Lost</div>
          <div class="tab_borderless" data-tab="deprecated">Deprecated</div>
          <div class="tab_borderless" data-tab="detached">Detached</div>
        </div>
      </div>
      <!-- Контент -->
      <div class="tabs-content">
        <!-- Подвкладки для инстансов -->


        <!-- Главная вкладка инстансов -->
        <div id="errorsTab" class="tab-content active">
        </div>
        <!-- Все инстансы -->
        <div id="instances" class="tab-content">
          <!-- Search Results -->
          <div id="searchResults" style="display: none;"></div>
          <div id="results">
            <a href="#" class="toggle-groups" data-action="expand">expand all</a>
            <ul id="resultsList"></ul>
          </div>
        </div>

        <div id="instances" class="tab-content">
        </div>
        <!-- Все инстансы -->
        <div id="instances" class="tab-content">
          <!-- Search Results -->
          <div id="searchResults" style="display: none;"></div>
          <div id="results">
            <a href="#" class="toggle-groups" data-action="expand">expand all</a>
            <ul id="resultsList"></ul>
          </div>
        </div>

        <!-- Устаревшие инстансы -->
        <div id="outdated" class="tab-content">
          <div id="outdatedResults">
            <a href="#" class="toggle-groups" data-action="expand">expand all</a>
            <ul id="outdatedResultsList"></ul>
          </div>
        </div>

        <!-- Потерянные инстансы -->
        <div id="lost" class="tab-content">
          <div id="lostResults">
            <a href="#" class="toggle-groups" data-action="expand">expand all</a>
            <ul id="lostResultsList"></ul>
          </div>
        </div>

        <!-- Устаревшие компоненты -->
        <div id="deprecated" class="tab-content">
          <div id="deprecatedResults">
            <a href="#" class="toggle-groups" data-action="expand">expand all</a>
            <ul id="deprecatedResultsList"></ul>
          </div>
        </div>

        <!-- Отсоединенные фреймы -->
        <div id="detached" class="tab-content">
          <div id="detachedResults">
            <a href="#" class="toggle-groups" data-action="expand">expand all</a>
            <ul id="detachedResultsList"></ul>
          </div>
        </div>

        <!-- Changelog -->
        <div id="log" class="tab-content">
          <h3>ToDo</h3>
          <p class="todo">Причесать UI
            <br>Не все иконки определяются корректно
            <br>Заменить hidden на иконку и добавить к группам из 1 элемента
            <br>В инстансах переписать вывод аналогично группам
            <br> Проверять fillStyleId для цветов
            <br> Поправить тег группы если внутри разные версии
            <br> Дополнительно в цветах группировать по типу элемента
          </p>
        </div>
        <!-- Иконки -->
        <div id="icons" class="tab-content">
          <div id="iconResults">
            <a href="#" class="toggle-groups" data-action="expand">expand all</a>
            <ul id="iconResultsList"></ul>
          </div>
        </div>
        <!-- Цвета -->
        <div id="colors" class="tab-content">
          <div id="colorResults">
            <a href="#" class="toggle-groups" data-action="expand">expand all</a>
            <ul id="colorResultsList"></ul>
            <ul id="colorStrokeResultsList"></ul>
          </div>
        </div>
        <!-- Total Statistics -->
        <div id="total" class="tab-content">
          <div class="stats-section">
            <ul id="overallStatsList" class="stats-list"></ul>
          </div>
        </div>
        <!-- Plugin Data -->
        <div id="component-data" class="tab-content">
          <h3>PluginData</h3>
          <p>Это трогать не надо!</p>
          <div style="margin-bottom: 15px;">
            <label for="componentKey">Ключ компонента:</label>
            <input type="text" id="componentKey" placeholder="Введите ключ"
              style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px;">
          </div>

          <div style="margin-bottom: 15px;">
            <label for="componentVersion">Версия компонента:</label>
            <input type="text" id="componentVersion" placeholder="Например, 1.0.0"
              style="width: 100%; padding: 8px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px;">
          </div>

          <div class="small-button-wrapper">
            <button id="readComponentData" class="button-secondary">Прочитать данные</button>
            <button id="setComponentData" class="button-secondary">Установить данные</button>
            <button id="clearComponentData" class="button-secondary">Очистить данные</button>
          </div>

          <div id="componentDataOutput"
            style="margin-top: 20px; min-height: 100px; border: 1px solid #eee; border-radius: 4px; padding: 10px; background-color: #f9f9f9;">
            <p class="placeholder-text" style="color: #888; font-style: italic;">Здесь будет отображаться результат
              операций.</p>
          </div>
        </div>
        <!-- Debug -->
        <div id="debug" class="tab-content">
          <h3>RAW Data</h3>
          <div class="search-container">
            <input type="text" id="debugSearchInput" placeholder="Поиск в отладочной информации...">
          </div>
          <div id="debugContent" class="debug-tree"></div>
        </div>
      </div>
      <!-- Footer -->
      <div class='footer'>
        <div class='wrapper'>
          <div class="user-info"></div>
          <div class="tabs">
            <div class="tab" id='metadata' data-tab="component-data">Metadata</div>
            <div class="tab" data-tab="debug">Debug</div>
            <div class="tab" data-tab="log">Backlog</div>
          </div>
        </div>
      </div>

      <script>


        // Проверяем наличие элементов
        const splashScreen = document.getElementById('splashScreen');
        const splashImage = document.querySelector('.splash-image');
        const loaderContainer = document.querySelector('.loader-container');
        const processedCount = document.getElementById('processedCount');
        const totalCount = document.getElementById('totalCount');
        const progressBarFill = document.querySelector('.progress-bar-fill');


        document.addEventListener('DOMContentLoaded', function () {

          // Инициализация вкладок
          const tabs = document.querySelectorAll('.tab[data-tab]'); // Выбираем только вкладки с атрибутом data-tab
          const subTabs = document.getElementById('subTabs');

          tabs.forEach(tab => {
            tab.addEventListener('click', () => {
              const tabId = tab.getAttribute('data-tab');

              // Проверяем, активен ли поиск
              const searchInput = document.getElementById('searchInput');
              const isSearchActive = searchInput && searchInput.value.trim() !== '';

              // Показываем соответствующий контент
              document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = content.id === tabId ? 'block' : 'none';
              });

              // Если поиск активен и выбрана вкладка instances, сохраняем отображение результатов поиска
              if (isSearchActive && tabId === 'errorsTab') {
                const searchResults = document.getElementById('searchResults');
                const resultsDiv = document.getElementById('results');
                if (searchResults && resultsDiv) {
                  searchResults.style.display = 'block';
                  resultsDiv.style.display = 'none';
                }
              }

              // Обновляем активную вкладку
              tabs.forEach(t => t.classList.remove('active'));
              tab.classList.add('active');

              // Показываем/скрываем дочерние вкладки в зависимости от выбранной вкладки
              if (subTabs) {
                const instancesRelatedTabs = ['errorsTab', 'review', 'colors', 'outdated', 'lost', 'deprecated', 'icons'];
                if (instancesRelatedTabs.includes(tabId)) {
                  subTabs.style.display = 'flex';

                  // Если переходим на errorsTab, автоматически активируем подвкладку All
                  if (tabId === 'errorsTab') {
                    // Сбрасываем активность всех подвкладок
                    document.querySelectorAll('.tab_borderless').forEach(subTab => {
                      subTab.classList.remove('active');
                    });
                    // Активируем подвкладку All (instances)
                    const allSubTab = document.querySelector('.tab_borderless[data-tab="review"]');
                    if (allSubTab) {
                      allSubTab.classList.add('active');
                    }
                    // Показываем контент вкладки instances
                    document.querySelectorAll('.tab-content').forEach(content => {
                      content.style.display = content.id === 'review' ? 'block' : 'none';
                    });
                  }
                } else {
                  subTabs.style.display = 'none';
                  // Сбрасываем активность дочерних вкладок
                  document.querySelectorAll('.tab_borderless').forEach(subTab => {
                    subTab.classList.remove('active');
                  });
                }
              }
            });
          });

          // Инициализация дочерних вкладок
          const subTabElements = document.querySelectorAll('.tab_borderless[data-tab]');
          subTabElements.forEach(subTab => {
            subTab.addEventListener('click', () => {
              const tabId = subTab.getAttribute('data-tab');

              // Проверяем, активен ли поиск
              const searchInput = document.getElementById('searchInput');
              const isSearchActive = searchInput && searchInput.value.trim() !== '';

              // Показываем соответствующий контент
              document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = content.id === tabId ? 'block' : 'none';
              });

              // Если поиск активен и выбрана вкладка instances (All), сохраняем отображение результатов поиска
              if (isSearchActive && tabId === 'errorsTab') {
                const searchResults = document.getElementById('searchResults');
                const resultsDiv = document.getElementById('results');
                if (searchResults && resultsDiv) {
                  searchResults.style.display = 'block';
                  resultsDiv.style.display = 'none';
                }
              }

              // Обновляем активную дочернюю вкладку
              subTabElements.forEach(t => t.classList.remove('active'));
              subTab.classList.add('active');

              // Убираем активность с основных вкладок, кроме errorsTab
              tabs.forEach(t => {
                if (t.getAttribute('data-tab') !== 'errorsTab') {
                  t.classList.remove('active');
                }
              });

              // Обеспечиваем, что основная вкладка errorsTab остается активной
              const instancesTab = document.querySelector('.tab[data-tab="errorsTab"]');
              if (instancesTab) {
                instancesTab.classList.add('active');
              }
            });
          });




        });




        // Добавляем обработчик для кнопки на splash screen
        document.getElementById('startCheck').addEventListener('click', () => {
          //console.log('Кнопка startCheck нажата');
          const loaderContainer = document.querySelector('.loader-container');
          loaderContainer.style.display = 'flex';

          // Скрываем splash screen и показываем основной контент
          document.getElementById('splashScreen').style.display = 'none';
          document.getElementById('mainContent').style.display = 'block';

          // Запускаем проверку
          parent.postMessage({ pluginMessage: { type: 'check-all' } }, '*');
        });

        document.getElementById('checkAll').addEventListener('click', () => {
          const loaderContainer = document.querySelector('.loader-container');
          loaderContainer.style.display = 'flex';
          parent.postMessage({ pluginMessage: { type: 'check-all' } }, '*');
        });


        // Обработчик для кнопки "Прочитать данные"
        document.getElementById('readComponentData').addEventListener('click', function () {
          //console.log('Запрос на чтение данных компонента');
          parent.postMessage({ pluginMessage: { type: 'get-component-data' } }, '*');
        });


        // Обработчик для кнопки "Установить данные"
        document.getElementById('setComponentData').addEventListener('click', function () {
          const key = document.getElementById('componentKey').value.trim();
          const version = document.getElementById('componentVersion').value.trim();

          //console.log('Запрос на установку данных компонента:', { key, version });

          if (!key || !version) {
            UIModules.displayResult('Пожалуйста, введите ключ и версию компонента.', true);
            return;
          }

          parent.postMessage({ pluginMessage: { type: 'set-component-data', key, version } }, '*');
        });

        // Обработчик для кнопки "Очистить данные"
        document.getElementById('clearComponentData').addEventListener('click', function () {
          //console.log('Запрос на очистку данных компонента');
          parent.postMessage({ pluginMessage: { type: 'clear-component-data' } }, '*');
        });



        const tabs = document.querySelectorAll('.tab');

        const tabContents = document.querySelectorAll('.tab-content');
        tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            // Deactivate all tabs and tab contents
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(tc => tc.classList.remove('active'));
            // Activate the clicked tab and its corresponding content
            tab.classList.add('active');
            const target = document.getElementById(tab.dataset.tab);
            target.classList.add('active');
          });
        });





        // Add after the existing tab switching logic
        document.querySelectorAll('.toggle-groups').forEach(toggle => {
          toggle.addEventListener('click', (e) => {
            e.preventDefault();
            const container = e.target.closest('div');
            const groupItems = container.querySelectorAll('.group-items');
            const isExpanding = e.target.dataset.action === 'expand';

            // Toggle all groups
            groupItems.forEach(group => {
              group.classList.toggle('expanded', isExpanding);
            });

            // Update toggle text and action
            e.target.textContent = isExpanding ? 'collapse all' : 'expand all';
            e.target.dataset.action = isExpanding ? 'collapse' : 'expand';
          });
        });


        // Добавляем обработчик для нового toggle "Show hidden"
        const showHiddenToggle = document.getElementById('showHiddenToggle');
        if (showHiddenToggle) {
          showHiddenToggle.addEventListener('change', () => {
            // Перерисовываем список инстансов при изменении состояния toggle
            if (window.lastDebugData) {
              if (window.lastDebugData.components) {
                const resultsList = document.getElementById('resultsList');
                const iconResultsList = document.getElementById('iconResultsList');
                let allInstances = [];
                UIModules.processAndDisplayComponents(window.lastDebugData.components, allInstances, resultsList, iconResultsList);
              }
              if (window.lastDebugData.components) {
                const outdatedResultsList = document.getElementById('outdatedResultsList');
                let allInstances = [];
                UIModules.processAndDisplayComponents(window.lastDebugData.components, allInstances, outdatedResultsList, null, 'outdated');
              }
              if (window.lastDebugData.components) {
                const lostResultsList = document.getElementById('lostResultsList');
                let allInstances = [];
                UIModules.processAndDisplayComponents(window.lastDebugData.components, allInstances, lostResultsList, null, 'lost');
              }
              // Re-process and display colors
              UIModules.processAndDisplayColors(window.lastDebugData.colors, window.lastDebugData.colorsStroke);
            }
          });
        }
        const searchInput = document.getElementById('searchInput');
        const clearSearch = document.getElementById('clearSearch');
        const searchResults = document.getElementById('searchResults');
        const debugContent = document.getElementById('debug').querySelector('#debugContent');
        let allInstances = []; // Store all instances for searching
        let originalDebugContent = null;

        const debugSearchInput = document.getElementById('debugSearchInput');
        const debugClearSearch = document.getElementById('debugClearSearch');

        // Добавляем обработчик для поиска в debug
        debugSearchInput.addEventListener('input', function () {
          const searchTerm = this.value.trim();
          //console.log('Debug search term:', searchTerm);

          // Если это первый поиск, сохраняем оригинальное содержимое
          if (!originalDebugContent) {
            originalDebugContent = debugContent.innerHTML;
          }

          // Если поле поиска пустое, восстанавливаем оригинальное содержимое
          if (!searchTerm) {
            debugContent.innerHTML = originalDebugContent;
            return;
          }

          // Пересоздаем дерево с учетом поискового запроса
          const debugData = {
            type: 'debug-search',
            components: window.lastDebugData?.components || {},
            colors: window.lastDebugData?.colors || {},
            componentTree: window.lastDebugData?.componentTree || null,
            totalStats: window.lastDebugData?.totalStats || {}
          };

          debugContent.innerHTML = '';
          const newTree = UIModules.createDebugTree(debugData, searchTerm);
          if (newTree) {
            debugContent.appendChild(newTree);
          }
        });

        // Обновляем обработчик сообщений для сохранения данных отладки
        // Define displayComponentData in the global scope first
        window.displayComponentData = function (data) {
          const outputElement = document.getElementById('componentDataOutput');
          if (!outputElement) {
            console.error('Элемент вывода не найден');
            return;
          }

          outputElement.innerHTML = '';

          if (!data || Object.keys(data).length === 0) {
            UIModules.displayResult('Данные компонента не найдены.', true);
            return;
          }

          const container = document.createElement('div');
          container.style.fontFamily = 'monospace';

          for (const nodeId in data) {
            const nodeData = data[nodeId];

            const nodeTitle = document.createElement('h4');
            nodeTitle.textContent = `Компонент: ${nodeData.name || 'Без имени'}`;
            nodeTitle.style.marginBottom = '5px';
            container.appendChild(nodeTitle);

            const nodeInfo = document.createElement('div');
            nodeInfo.style.marginLeft = '10px';
            nodeInfo.style.marginBottom = '15px';

            const idLine = document.createElement('div');
            idLine.textContent = `ID: ${nodeId}`;
            nodeInfo.appendChild(idLine);

            const keyLine = document.createElement('div');
            keyLine.textContent = `Ключ: ${nodeData.key || 'Не установлен'}`;
            keyLine.style.color = nodeData.key ? '#2e7d32' : '#d32f2f';
            nodeInfo.appendChild(keyLine);

            const versionLine = document.createElement('div');
            versionLine.textContent = `Версия: ${nodeData.version || 'Не установлена'}`;
            versionLine.style.color = nodeData.version ? '#2e7d32' : '#d32f2f';
            nodeInfo.appendChild(versionLine);

            if (nodeData.originalKey) {
              const originalKeyLine = document.createElement('div');
              originalKeyLine.textContent = `Оригинальный ключ: ${nodeData.originalKey}`;
              originalKeyLine.style.color = '#666';
              nodeInfo.appendChild(originalKeyLine);
            }

            container.appendChild(nodeInfo);
          }

          outputElement.appendChild(container);
        };

        // Then define the message handler
        window.onmessage = (event) => {
          const msg = event.data.pluginMessage;
          if (!msg) return;

          // Handle special cases first
          if (msg.type === 'user-info') {
            const userInfoElement = document.querySelector('.user-info');
            const metadataTab = document.getElementById('metadata');
            if (userInfoElement) {
              if (!["Konstantin Kuzin", "III", "YYY"].includes(msg.user.name)) metadataTab.style.display = 'none';
              userInfoElement.textContent = msg.user.name;
            }
            return;
          }

          // Handle splash-data message
          if (msg.type === 'splash-data') {
            const splashImageElement = document.querySelector('.splash-image');
            const splashTitleElement = document.querySelector('.splash-title');
            const startCheckButton = document.getElementById('startCheck');

            if (splashImageElement && msg.data.imageUrl) {
              splashImageElement.src = msg.data.imageUrl;
            }
            if (splashTitleElement && msg.data.titleText) {
              splashTitleElement.textContent = msg.data.titleText;
            }
            if (startCheckButton && msg.data.buttonText) {
              startCheckButton.textContent = msg.data.buttonText;
            }
            return;
          }

          if (msg.type === 'resize') {
            const width = msg.width;
            const height = msg.height;
            window.resizeTo(width, height);
            return;
          }

          if (msg.type === 'display-total') {
            UIModules.displayTabTotal(msg.data);
            return;
          }

          if (msg.type === 'success') {
            hideLoader();

            // Очищаем предыдущие результаты
            const resultsList = document.getElementById('colorResultsList');
            if (resultsList) {
              resultsList.innerHTML = '';

              if (msg.instances && msg.instances.length > 0) {
                UIModules.displayGroups(msg.instances, resultsList, 'colors');
              } else { resultsList.innerHTML = '<p>Цвета не найдены</p>'; }
            }
            else {
              //console.error('Не найден элемент colorResultsList');
            }
          }
          if (msg.type === 'progress-update') {
            // Показываем контейнер загрузки, если он еще не показан
            loaderContainer.style.display = 'flex';

            // Обновляем информацию о прогрессе
            processedCount.textContent = msg.processed;
            totalCount.textContent = msg.total;

            // Обновляем прогресс-бар
            const percentage = (msg.processed / msg.total) * 100;
            progressBarFill.style.width = `${percentage}%`;
            // Показываем имя компонента
            if (msg.currentComponentName) {
              document.getElementById('progressPhase').textContent = `${msg.currentComponentName}`;
            } else if (msg.type === 'progress-update' && msg.phase === 'check-updates') {
              document.getElementById('progressPhase').textContent = 'Проверка обновлений...';
            } else {
              document.getElementById('progressPhase').textContent = '';
            }
          }
          if (msg.type === 'all-results') {

            // Save data for search
            window.lastDebugData = {
              components: msg.components,
              colors: msg.colors,
              colorsStroke: msg.colorsStroke,
              componentTree: msg.componentTree,
              totalStats: msg.totalStats
            };

            // Hide loader
            const loaderContainer = document.querySelector('.loader-container');
            if (loaderContainer) { loaderContainer.style.display = 'none'; }

            // Process components
            if (msg.components) {
              const resultsList = document.getElementById('resultsList');
              const iconResultsList = document.getElementById('iconResultsList');
              let allInstances = [];
              UIModules.processAndDisplayComponents(msg.components, allInstances, resultsList, iconResultsList);

              // Показываем нижние вкладки после обработки результатов поиска
              const subTabs = document.getElementById('subTabs');
              if (subTabs) {
                subTabs.style.display = 'flex';
              }

              // Активируем вкладку Instances
              const instancesTab = document.querySelector('.tab[data-tab="errorsTab"]');
              if (instancesTab) {
                // Убираем активность со всех основных вкладок
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                // Активируем вкладку Instances
                instancesTab.classList.add('active');
              }

              // Активируем подвкладку "All" по умолчанию и показываем её контент
              const allSubTab = document.querySelector('.tab_borderless[data-tab="review"]');
              if (allSubTab) {
                document.querySelectorAll('.tab_borderless').forEach(t => t.classList.remove('active'));
                allSubTab.classList.add('active');

                // Показываем только контент подвкладки "All" (instances)
                document.querySelectorAll('.tab-content').forEach(content => {
                  content.style.display = content.id === 'instances' ? 'block' : 'none';
                });
              }
            }

            // Process outdated components if present
            if (msg.components) {
              const outdatedResultsList = document.getElementById('outdatedResultsList');
              let allInstances = [];
              UIModules.processAndDisplayComponents(msg.components, allInstances, outdatedResultsList, null, 'outdated');
            }

            // Process lost components if present
            if (msg.components) {
              const lostResultsList = document.getElementById('lostResultsList');
              let allInstances = [];
              UIModules.processAndDisplayComponents(msg.components, allInstances, lostResultsList, null, 'lost');
            }

            // Process deprecated components if present
            if (msg.components) {
              const deprecatedResultsList = document.getElementById('deprecatedResultsList');
              let allInstances = [];
              UIModules.processAndDisplayComponents(msg.components, allInstances, deprecatedResultsList, null, 'deprecated');
            }

            // Process detached components if present
            if (msg.components) {
              const detachedResultsList = document.getElementById('detachedResultsList');
              let allInstances = [];
              UIModules.processAndDisplayComponents(msg.components, allInstances, detachedResultsList, null, 'detached');
            }

            // Process colors
            if (msg.colors) {
              UIModules.processAndDisplayColors(msg.colors, msg.colorsStroke);
            }

            // Update debug information
            debugContent.innerHTML = '';
            debugContent.className = 'debug-tree';

            // Create formatted debug output
            const debugData = {
              type: msg.type,
              timestamp: new Date().toISOString(),
              components: msg.components,
              colors: msg.colors,
              colorsStroke: msg.colorsStroke,
              componentTree: msg.componentTree,
              totalStats: msg.totalStats
            };

            // Сбрасываем сохраненное оригинальное содержимое при новых данных
            originalDebugContent = null;

            // Преобразуем данные в древовидную структуру
            const tree = UIModules.createDebugTree(debugData);
            if (tree) {
              debugContent.appendChild(tree);
              //console.log('Отладочная информация обновлена');
            } else {
              //console.error('Не удалось создать дерево отладки');
            }
          }
          if (msg.type === 'connection-waiting') {
            // Показываем сообщение о проблемах с соединением
            loaderContainer.style.display = 'flex';
            document.getElementById('progressPhase').textContent = 'Waiting for connection...';
            processedCount.textContent = '0';
            totalCount.textContent = '0';
            progressBarFill.style.width = '0%';
            return;
          }

          if (msg.type === 'retry-notification') {
            // Показываем сообщение о повторной попытке, но только если счетчик еще не запущен
            const currentPhase = document.getElementById('progressPhase').textContent;
            if (!currentPhase.includes('из')) {
              document.getElementById('progressPhase').textContent = msg.message;
            }
            return;
          }

          if (msg.type === 'error') {
            // Проверяем, является ли это ошибкой соединения
            const isConnectionError = msg.message && (
              msg.message.includes('Соединение с Figma недоступно') ||
              msg.message.includes('Не удалось восстановить соединение')
            );

            if (!isConnectionError) {
              loaderContainer.style.display = 'none';
            }

            // Удаляем предыдущее сообщение об ошибке, если оно есть
            const existingError = document.querySelector('.error-message');
            if (existingError) {
              existingError.remove();
            }

            // Создаем новое сообщение об ошибке
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            const errorText = document.createElement('p');
            errorText.textContent = msg.message;
            errorDiv.appendChild(errorText);
            document.body.appendChild(errorDiv);

            // Автоматически скрываем сообщение через 3 секунды
            setTimeout(() => { errorDiv.remove(); }, 5000);

            // Добавляем ошибку в отладочную информацию
            const debugError = document.createElement('div');
            debugError.style.color = 'red';
            debugError.textContent = `Error: ${msg.message}`;
            debugContent.appendChild(debugError);
          }

          if (msg.type === 'component-data-result') {
            if (msg.data) {
              displayComponentData(msg.data);
            } else if (msg.message) {
              UIModules.displayResult(msg.message, msg.isError);
            } else {
              UIModules.displayResult('Данные компонента не найдены.');
            }
            return;
          }

          if (msg.type === 'component-data-set') {
            UIModules.displayResult(msg.message || 'Данные компонента успешно установлены.', msg.isError);
            return;
          }

          if (msg.type === 'component-data-cleared') {
            UIModules.displayResult(msg.message || 'Данные компонента успешно очищены.', msg.isError);
            return;
          }


          // Выполняем после загрузки страницы
          window.addEventListener('DOMContentLoaded', function () {

            // Определяем глобальную функцию displayComponentData
            window.displayComponentData = function (data) {
              const outputElement = document.getElementById('componentDataOutput');
              if (!outputElement) {
                console.error('Элемент вывода не найден');
                return;
              }

              outputElement.innerHTML = '';

              if (!data || Object.keys(data).length === 0) {
                UIModules.displayResult('Данные компонента не найдены.', true);
                return;
              }

              const container = document.createElement('div');
              container.style.fontFamily = 'monospace';

              for (const nodeId in data) {
                const nodeData = data[nodeId];

                const nodeTitle = document.createElement('h4');
                nodeTitle.textContent = `Компонент: ${nodeData.name || 'Без имени'}`;
                nodeTitle.style.marginBottom = '5px';
                container.appendChild(nodeTitle);

                const nodeInfo = document.createElement('div');
                nodeInfo.style.marginLeft = '10px';
                nodeInfo.style.marginBottom = '15px';

                const idLine = document.createElement('div');
                idLine.textContent = `ID: ${nodeId}`;
                nodeInfo.appendChild(idLine);

                const keyLine = document.createElement('div');
                keyLine.textContent = `Ключ: ${nodeData.key || 'Не установлен'}`;
                keyLine.style.color = nodeData.key ? '#2e7d32' : '#d32f2f';
                nodeInfo.appendChild(keyLine);

                const versionLine = document.createElement('div');
                versionLine.textContent = `Версия: ${nodeData.version || 'Не установлена'}`;
                versionLine.style.color = nodeData.version ? '#2e7d32' : '#d32f2f';
                nodeInfo.appendChild(versionLine);

                // Добавляем отображение данных из PluginData
                if (nodeData.pluginDataKey || nodeData.pluginDataVersion) {
                  // Добавляем заголовок для данных из PluginData
                  const pluginDataHeader = document.createElement('div');
                  pluginDataHeader.textContent = 'Данные из PluginData:';
                  pluginDataHeader.style.fontWeight = 'bold';
                  pluginDataHeader.style.marginTop = '8px';
                  pluginDataHeader.style.marginBottom = '4px';
                  nodeInfo.appendChild(pluginDataHeader);

                  // Отображаем ключ из PluginData
                  const pluginDataKeyLine = document.createElement('div');
                  pluginDataKeyLine.textContent = `Ключ из PluginData: ${nodeData.pluginDataKey || 'Не установлен'}`;
                  pluginDataKeyLine.style.color = nodeData.pluginDataKey ? '#2e7d32' : '#d32f2f';
                  pluginDataKeyLine.style.marginLeft = '10px';
                  nodeInfo.appendChild(pluginDataKeyLine);

                  // Отображаем версию из PluginData
                  const pluginDataVersionLine = document.createElement('div');
                  pluginDataVersionLine.textContent = `Версия из PluginData: ${nodeData.pluginDataVersion || 'Не установлена'}`;
                  pluginDataVersionLine.style.color = nodeData.pluginDataVersion ? '#2e7d32' : '#d32f2f';
                  pluginDataVersionLine.style.marginLeft = '10px';
                  nodeInfo.appendChild(pluginDataVersionLine);
                }

                container.appendChild(nodeInfo);
              }

              outputElement.appendChild(container);
            };

            // Переопределяем обработчик сообщений
            const originalMessageHandler = window.onmessage;
            window.addEventListener('message', function (event) {
              if (!event.data.pluginMessage) return;

              const msg = event.data.pluginMessage;
              //console.log('Получено сообщение от плагина:', msg);

              // Обработка сообщений для компонентов
              switch (msg.type) {
                case 'component-data-result':
                  if (msg.data) {
                    const outputElement = document.getElementById('componentDataOutput');
                    if (!outputElement) {
                      console.error('Элемент вывода не найден');
                      return;
                    }

                    outputElement.innerHTML = '';

                    if (Object.keys(msg.data).length === 0) {
                      UIModules.displayResult('Данные компонента не найдены.', true);
                      return;
                    }

                    const container = document.createElement('div');
                    container.style.fontFamily = 'monospace';

                    for (const nodeId in msg.data) {
                      const nodeData = msg.data[nodeId];

                      const nodeTitle = document.createElement('h4');
                      nodeTitle.textContent = `Компонент: ${nodeData.name || 'Без имени'}`;
                      nodeTitle.style.marginBottom = '5px';
                      container.appendChild(nodeTitle);

                      const nodeInfo = document.createElement('div');
                      nodeInfo.style.marginLeft = '10px';
                      nodeInfo.style.marginBottom = '15px';

                      const idLine = document.createElement('div');
                      idLine.textContent = `ID: ${nodeId}`;
                      nodeInfo.appendChild(idLine);

                      const keyLine = document.createElement('div');
                      keyLine.textContent = `Ключ: ${nodeData.key || 'Не установлен'}`;
                      keyLine.style.color = nodeData.key ? '#2e7d32' : '#d32f2f';
                      nodeInfo.appendChild(keyLine);

                      const versionLine = document.createElement('div');
                      versionLine.textContent = `Версия: ${nodeData.version || 'Не установлена'}`;
                      versionLine.style.color = nodeData.version ? '#2e7d32' : '#d32f2f';
                      nodeInfo.appendChild(versionLine);

                      if (nodeData.originalKey) {
                        const originalKeyLine = document.createElement('div');
                        originalKeyLine.textContent = `Оригинальный ключ: ${nodeData.originalKey}`;
                        originalKeyLine.style.color = '#666';
                        nodeInfo.appendChild(originalKeyLine);
                      }

                      container.appendChild(nodeInfo);
                    }

                    outputElement.appendChild(container);
                  } else if (msg.message) {
                    UIModules.displayResult(msg.message, msg.isError);
                  } else {
                    UIModules.displayResult('Данные компонента не найдены.');
                  }
                  break;

                case 'component-data-set':
                  UIModules.displayResult(msg.message || 'Данные компонента успешно установлены.', msg.isError);
                  break;

                case 'component-data-cleared':
                  UIModules.displayResult(msg.message || 'Данные компонента успешно очищены.', msg.isError);
                  break;
              }
            });


          });

        };



        // Обработка ресайза окна
        const resizeHandle = document.getElementById('resizeHandle');
        let isResizing = false;
        let initialWidth;
        let initialHeight;
        let initialX;
        let initialY;

        resizeHandle.addEventListener('mousedown', (e) => {
          isResizing = true;
          initialWidth = window.innerWidth;
          initialHeight = window.innerHeight;
          initialX = e.clientX;
          initialY = e.clientY;
        });

        document.addEventListener('mousemove', (e) => {
          if (!isResizing) return;

          const newWidth = initialWidth + (e.clientX - initialX);
          const newHeight = initialHeight + (e.clientY - initialY);

          // Ensure minimum dimensions
          const width = Math.max(newWidth, 300);
          const height = Math.max(newHeight, 200);

          // Directly resize the window
          window.resizeTo(width, height);

          // Also notify the plugin
          parent.postMessage({
            pluginMessage: {
              type: 'resize',
              width: width,
              height: height
            }
          }, '*');

          // Prevent selection during resize
          e.preventDefault();
        });

        document.addEventListener('mouseup', () => { isResizing = false; });


        // Search functionality
        if (searchInput && clearSearch && searchResults) {
          searchInput.addEventListener('input', () => {
            const searchTerm = searchInput.value.toLowerCase();
            clearSearch.style.display = searchTerm ? 'block' : 'none';

            if (!searchTerm) {
              searchResults.innerHTML = '';
              searchResults.style.display = 'none';
              // Показываем обычный контент instances
              const resultsDiv = document.getElementById('results');
              if (resultsDiv) {
                resultsDiv.style.display = 'block';
              }
              // Возвращаемся к активной вкладке
              const activeTab = document.querySelector('.tab.active');
              if (activeTab) {
                const tabId = activeTab.getAttribute('data-tab');
                document.querySelectorAll('.tab-content').forEach(content => {
                  content.style.display = content.id === tabId ? 'block' : 'none';
                });
              }
              return;
            }

            const results = allInstances.filter(instance => {
              const name = instance.name.toLowerCase();
              const description = (instance.description || '').toLowerCase();
              return name.includes(searchTerm) || description.includes(searchTerm);
            });

            // Показываем результаты поиска
            searchResults.style.display = 'block';

            // Показываем вкладки errorsTab и instances
            document.querySelectorAll('.tab-content').forEach(content => {
              content.style.display = (content.id === 'instances' || content.id === 'errorsTab') ? 'block' : 'none';
            });

            // Переключаемся на вкладку Instances и показываем дочернюю вкладку All
            tabs.forEach(t => t.classList.remove('active'));
            const instancesTab = document.querySelector('.tab[data-tab="errorsTab"]');
            if (instancesTab) {
              instancesTab.classList.add('active');
            }

            // Показываем дочерние вкладки и активируем All
            const subTabs = document.getElementById('subTabs');
            if (subTabs) {
              subTabs.style.display = 'flex';
              const subTabElements = subTabs.querySelectorAll('.tab_borderless');
              subTabElements.forEach(t => t.classList.remove('active'));
              const allSubTab = subTabs.querySelector('.tab_borderless[data-tab="review"]');
              if (allSubTab) {
                allSubTab.classList.add('active');
              }
            }

            UIModules.displaySearchResults(results, searchTerm);
          });

          // Clear search
          clearSearch.addEventListener('click', () => {
            searchInput.value = '';
            searchResults.innerHTML = '';
            searchResults.style.display = 'none';
            clearSearch.style.display = 'none';

            // Показываем обычный контент instances
            const resultsDiv = document.getElementById('results');
            if (resultsDiv) {
              resultsDiv.style.display = 'block';
            }

            // Возвращаемся к активной вкладке
            const activeTab = document.querySelector('.tab.active');
            if (activeTab) {
              const tabId = activeTab.getAttribute('data-tab');
              document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = content.id === tabId ? 'block' : 'none';
              });
            }
          });
        }

        // Functions moved to UIModules

        // Removed duplicate check-updates handler and redundant inputs init (moved earlier)

      </script>
<script>"use strict";
(() => {
  // src/ui/createIcon.ts
  var createIcon = (type) => {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    let iconClass = "info-icon";
    let iconId = "info-icon";
    switch (type) {
      case "INSTANCE":
        iconClass = "instance-icon";
        iconId = "instance-icon";
        break;
      case "TEXT":
        iconClass = "text-icon";
        iconId = "text-icon";
        break;
      case "FRAME":
        iconClass = "frame-icon";
        iconId = "frame-icon";
        break;
      case "RECTANGLE":
        iconClass = "rectangle-icon";
        iconId = "rectangle-icon";
        break;
      case "VECTOR":
        iconClass = "frame-icon";
        iconId = "frame-icon";
        break;
    }
    svg.classList.add(iconClass);
    const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
    use.setAttributeNS("http://www.w3.org/1999/xlink", "href", `#${iconId}`);
    svg.appendChild(use);
    return svg;
  };
})();

"use strict";
(() => {
  // src/ui/displayComponentData.ts
  function displayComponentData(data) {
    const outputElement = document.getElementById("componentDataOutput");
    if (!outputElement) {
      console.error("\u042D\u043B\u0435\u043C\u0435\u043D\u0442 \u0432\u044B\u0432\u043E\u0434\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D");
      return;
    }
    outputElement.innerHTML = "";
    if (!data || Object.keys(data).length === 0) {
      window.UIModules.displayResult("\u0414\u0430\u043D\u043D\u044B\u0435 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B.", true);
      return;
    }
    const container = document.createElement("div");
    container.style.fontFamily = "monospace";
    for (const nodeId in data) {
      const nodeData = data[nodeId];
      const nodeTitle = document.createElement("h4");
      nodeTitle.textContent = `\u041A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442: ${nodeData.name || "\u0411\u0435\u0437 \u0438\u043C\u0435\u043D\u0438"}`;
      nodeTitle.style.marginBottom = "5px";
      container.appendChild(nodeTitle);
      const nodeInfo = document.createElement("div");
      nodeInfo.style.marginLeft = "10px";
      nodeInfo.style.marginBottom = "15px";
      const idLine = document.createElement("div");
      idLine.textContent = `ID: ${nodeId}`;
      nodeInfo.appendChild(idLine);
      const keyLine = document.createElement("div");
      keyLine.textContent = `\u041A\u043B\u044E\u0447: ${nodeData.key || "\u041D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D"}`;
      keyLine.style.color = nodeData.key ? "#2e7d32" : "#d32f2f";
      nodeInfo.appendChild(keyLine);
      const versionLine = document.createElement("div");
      versionLine.textContent = `\u0412\u0435\u0440\u0441\u0438\u044F: ${nodeData.version || "\u041D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0430"}`;
      versionLine.style.color = nodeData.version ? "#2e7d32" : "#d32f2f";
      nodeInfo.appendChild(versionLine);
      if (nodeData.pluginDataKey || nodeData.pluginDataVersion) {
        const pluginDataKeyLine = document.createElement("div");
        pluginDataKeyLine.textContent = `\u041A\u043B\u044E\u0447 \u0438\u0437 PluginData: ${nodeData.pluginDataKey || "\u041D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D"}`;
        pluginDataKeyLine.style.color = nodeData.pluginDataKey ? "#2e7d32" : "#d32f2f";
        pluginDataKeyLine.style.marginLeft = "10px";
        nodeInfo.appendChild(pluginDataKeyLine);
        const pluginDataVersionLine = document.createElement("div");
        pluginDataVersionLine.textContent = `\u0412\u0435\u0440\u0441\u0438\u044F \u0438\u0437 PluginData: ${nodeData.pluginDataVersion || "\u041D\u0435 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u0430"}`;
        pluginDataVersionLine.style.color = nodeData.pluginDataVersion ? "#2e7d32" : "#d32f2f";
        pluginDataVersionLine.style.marginLeft = "10px";
        nodeInfo.appendChild(pluginDataVersionLine);
      }
      container.appendChild(nodeInfo);
    }
    outputElement.appendChild(container);
  }
  if (typeof window !== "undefined") {
    window.UIModules = window.UIModules || {};
    window.UIModules.displayComponentData = displayComponentData;
    window.displayComponentData = displayComponentData;
  }
})();

"use strict";
(() => {
  // src/ui/displayResult.ts
  var displayResult = (message, isError = false) => {
    const outputElement = document.getElementById("componentDataOutput");
    if (!outputElement) {
      console.error("\u042D\u043B\u0435\u043C\u0435\u043D\u0442 \u0432\u044B\u0432\u043E\u0434\u0430 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D");
      return;
    }
    outputElement.innerHTML = "";
    const resultElement = document.createElement("p");
    resultElement.textContent = message;
    resultElement.style.color = isError ? "#d32f2f" : "#2e7d32";
    resultElement.style.fontWeight = "bold";
    resultElement.style.padding = "10px";
    resultElement.style.border = `1px solid ${isError ? "#d32f2f" : "#2e7d32"}`;
    resultElement.style.borderRadius = "4px";
    outputElement.appendChild(resultElement);
  };
  if (typeof window !== "undefined") {
    window.UIModules = window.UIModules || {};
    window.UIModules.displayResult = displayResult;
  }
})();

"use strict";
(() => {
  // src/ui/showPopover.ts
  var showPopover = (icon, instance) => {
    const popover = document.createElement("div");
    popover.classList.add("popover");
    const content = Object.entries(instance).map(([key, value]) => {
      const boldKey = `<strong>${key}:</strong>`;
      if (typeof value === "object" && value !== null) {
        try {
          return `${boldKey} ${JSON.stringify(value)}`;
        } catch (e) {
          return `${boldKey} [object]`;
        }
      }
      return `${boldKey} ${value}`;
    }).join("<br>");
    popover.innerHTML = content;
    const maxWidth = Math.min(500, window.innerWidth - 40);
    const maxHeight = window.innerHeight - 40;
    popover.style.maxWidth = `${maxWidth}px`;
    popover.style.maxHeight = `${maxHeight}px`;
    popover.style.overflowY = "auto";
    popover.style.wordWrap = "break-word";
    document.body.appendChild(popover);
    const rect = icon.getBoundingClientRect();
    popover.style.visibility = "hidden";
    popover.style.display = "block";
    const popoverRect = popover.getBoundingClientRect();
    popover.style.display = "none";
    popover.style.visibility = "visible";
    let top = rect.bottom + 5;
    let left = rect.left;
    if (left + popoverRect.width > window.innerWidth - 10) {
      left = window.innerWidth - popoverRect.width - 10;
    }
    if (left < 10) {
      left = 10;
    }
    if (top + popoverRect.height > window.innerHeight - 10) {
      top = rect.top - popoverRect.height - 5;
    }
    if (top < 10) {
      top = 10;
    }
    popover.style.left = `${left}px`;
    popover.style.top = `${top}px`;
    popover.style.display = "block";
    const onLeave = () => {
      popover.remove();
      try {
        icon.removeEventListener("mouseleave", onLeave);
      } catch (e) {
      }
    };
    icon.addEventListener("mouseleave", onLeave);
  };
})();

"use strict";
(() => {
  // src/ui/sortGroups.ts
  function sortGroups(groups) {
    return Object.fromEntries(
      Object.entries(groups).sort(([, groupAItems], [, groupBItems]) => {
        const firstItemA = groupAItems[0];
        const firstItemB = groupBItems[0];
        const aName = (firstItemA.mainComponentSetName || firstItemA.mainComponentName || firstItemA.name || "").replace(/([\u0023-\u0039]\uFE0F?\u20E3|\u00A9|\u00AE|[\u2000-\u3300]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|\uD83E[\uDC00-\uDFFF])/gu, "").trim().replace(/^[^a-zA-Z0-9\/]+/, "");
        const bName = (firstItemB.mainComponentSetName || firstItemB.mainComponentName || firstItemB.name || "").replace(/([\u0023-\u0039]\uFE0F?\u20E3|\u00A9|\u00AE|[\u2000-\u3300]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|\uD83E[\uDC00-\uDFFF])/gu, "").trim().replace(/^[^a-zA-Z0-9\/]+/, "");
        const aSpecial = /^[._]/.test(aName);
        const bSpecial = /^[._]/.test(bName);
        if (aSpecial && !bSpecial) return 1;
        if (!aSpecial && bSpecial) return -1;
        return aName.localeCompare(bName, void 0, { numeric: true, sensitivity: "accent" });
      })
    );
  }
})();

"use strict";
(() => {
  // src/ui/displayTabTotal.ts
  function displayTabTotal(data) {
    const { overallStats } = data;
    const stats = overallStats;
    console.log("displayTabTotalStats:", overallStats);
    if (!overallStats || !stats.nodeTypeCounts) {
      console.log("No nodeTypeCounts found");
      return;
    }
    const totalTab = document.querySelector('[data-tab="total"]');
    if (totalTab) {
      totalTab.textContent = `Total (${stats.totalNodes})`;
      console.log("Updated total tab with count:", stats.totalNodes);
    }
    const overallStatsList = document.getElementById("overallStatsList");
    if (overallStatsList) {
      overallStatsList.innerHTML = "";
      const totalLi = document.createElement("li");
      totalLi.className = "stats-item";
      totalLi.innerHTML = `<span class="stats-type"><strong>TOTAL NODES</strong></span><span class="stats-count"><strong>${stats.totalNodes}</strong></span>`;
      overallStatsList.appendChild(totalLi);
      const sortedTypes = Object.entries(stats.nodeTypeCounts).sort(
        ([, a], [, b]) => b - a
      );
      for (const [type, count] of sortedTypes) {
        if (count > 0) {
          const li = document.createElement("li");
          li.className = "stats-item";
          li.innerHTML = `<span class="stats-type">${type}</span><span class="stats-count">${count}</span>`;
          overallStatsList.appendChild(li);
        }
      }
    }
  }
  if (typeof window !== "undefined") {
    window.UIModules = window.UIModules || {};
    window.UIModules.displayTabTotal = displayTabTotal;
  }
})();

"use strict";
(() => {
  // src/ui/createIcon.ts
  var createIcon = (type) => {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    let iconClass = "info-icon";
    let iconId = "info-icon";
    switch (type) {
      case "INSTANCE":
        iconClass = "instance-icon";
        iconId = "instance-icon";
        break;
      case "TEXT":
        iconClass = "text-icon";
        iconId = "text-icon";
        break;
      case "FRAME":
        iconClass = "frame-icon";
        iconId = "frame-icon";
        break;
      case "RECTANGLE":
        iconClass = "rectangle-icon";
        iconId = "rectangle-icon";
        break;
      case "VECTOR":
        iconClass = "frame-icon";
        iconId = "frame-icon";
        break;
    }
    svg.classList.add(iconClass);
    const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
    use.setAttributeNS("http://www.w3.org/1999/xlink", "href", `#${iconId}`);
    svg.appendChild(use);
    return svg;
  };

  // src/ui/showPopover.ts
  var showPopover = (icon, instance) => {
    const popover = document.createElement("div");
    popover.classList.add("popover");
    const content = Object.entries(instance).map(([key, value]) => {
      const boldKey = `<strong>${key}:</strong>`;
      if (typeof value === "object" && value !== null) {
        try {
          return `${boldKey} ${JSON.stringify(value)}`;
        } catch (e) {
          return `${boldKey} [object]`;
        }
      }
      return `${boldKey} ${value}`;
    }).join("<br>");
    popover.innerHTML = content;
    const maxWidth = Math.min(500, window.innerWidth - 40);
    const maxHeight = window.innerHeight - 40;
    popover.style.maxWidth = `${maxWidth}px`;
    popover.style.maxHeight = `${maxHeight}px`;
    popover.style.overflowY = "auto";
    popover.style.wordWrap = "break-word";
    document.body.appendChild(popover);
    const rect = icon.getBoundingClientRect();
    popover.style.visibility = "hidden";
    popover.style.display = "block";
    const popoverRect = popover.getBoundingClientRect();
    popover.style.display = "none";
    popover.style.visibility = "visible";
    let top = rect.bottom + 5;
    let left = rect.left;
    if (left + popoverRect.width > window.innerWidth - 10) {
      left = window.innerWidth - popoverRect.width - 10;
    }
    if (left < 10) {
      left = 10;
    }
    if (top + popoverRect.height > window.innerHeight - 10) {
      top = rect.top - popoverRect.height - 5;
    }
    if (top < 10) {
      top = 10;
    }
    popover.style.left = `${left}px`;
    popover.style.top = `${top}px`;
    popover.style.display = "block";
    const onLeave = () => {
      popover.remove();
      try {
        icon.removeEventListener("mouseleave", onLeave);
      } catch (e) {
      }
    };
    icon.addEventListener("mouseleave", onLeave);
  };

  // src/ui/displayVersionTag.ts
  function displayVersionTag(options) {
    const {
      instanceVersion = "      ",
      libraryVersion = "      ",
      checkVersion = "",
      isGroupHeader = false,
      groupItems = [],
      tabType = ""
    } = options;
    if (tabType === "deprecated" || tabType === "detached" || tabType === "lost") {
      const emptyContainer = document.createElement("span");
      emptyContainer.classList.add("version-group");
      return emptyContainer;
    }
    const versionGroup = document.createElement("span");
    versionGroup.classList.add("version-group");
    const versionBadge = document.createElement("span");
    versionBadge.classList.add("version-tag");
    if (isGroupHeader && groupItems) {
      const latestCount = groupItems.filter(
        (item) => item.checkVersion === "Latest"
      ).length;
      const notLatestCount = groupItems.filter(
        (item) => item.checkVersion === "NotLatest"
      ).length;
      const outdatedCount = groupItems.filter(
        (item) => item.checkVersion === "Outdated"
      ).length;
      if (latestCount === 0 && notLatestCount === 0 && outdatedCount === 0) {
        return versionGroup;
      }
      if (outdatedCount > 0) {
        const outdatedBadge = document.createElement("span");
        outdatedBadge.classList.add("version-tag", "version-tag-outdated");
        outdatedBadge.textContent = outdatedCount.toString();
        versionGroup.appendChild(outdatedBadge);
      }
      if (notLatestCount > 0) {
        const notLatestBadge = document.createElement("span");
        notLatestBadge.classList.add("version-tag", "version-tag-notlatest");
        notLatestBadge.textContent = notLatestCount.toString();
        versionGroup.appendChild(notLatestBadge);
      }
      if (latestCount > 0) {
        const latestBadge = document.createElement("span");
        latestBadge.classList.add("version-tag", "version-tag-latest");
        latestBadge.textContent = latestCount.toString();
        versionGroup.appendChild(latestBadge);
      }
      return versionGroup;
    } else {
      const hasInstanceVersion = instanceVersion && instanceVersion !== "none";
      const hasLibraryVersion = libraryVersion && libraryVersion !== "none";
      if (!hasInstanceVersion && !hasLibraryVersion) {
        return versionGroup;
      }
      if (hasLibraryVersion && checkVersion !== "Latest") {
        versionBadge.textContent = `${instanceVersion || "none"} \u2192 ${libraryVersion}`;
        if (checkVersion === "NotLatest") {
          versionBadge.classList.add("version-tag-notlatest");
        }
        if (checkVersion === "Outdated") {
          versionBadge.classList.add("version-tag-outdated");
        }
      } else if (hasInstanceVersion) {
        versionBadge.textContent = instanceVersion;
        if (checkVersion === "Latest") {
          versionBadge.classList.add("version-tag-latest");
        }
      } else {
        return versionGroup;
      }
    }
    if (!isGroupHeader && versionBadge.textContent) {
      versionGroup.appendChild(versionBadge);
    }
    return versionGroup;
  }

  // src/ui/displayGroups.ts
  var displayGroups = (groupedData, targetList, tabType = "") => {
    targetList.innerHTML = "";
    if (!targetList || !targetList.id) {
      console.error("Target list or its ID is undefined.");
      return;
    }
    for (const key in groupedData) {
      const group = groupedData[key];
      if (group.length === 0) continue;
      const firstInstance = group[0];
      const name = firstInstance.mainComponentSetName ? firstInstance.mainComponentSetName : firstInstance.mainComponentName ? firstInstance.mainComponentName : firstInstance.name;
      const groupHeader = document.createElement("ul");
      groupHeader.classList.add("group-header");
      const groupName = document.createElement("div");
      groupName.classList.add("group-name");
      const groupicon = document.createElement("div");
      groupicon.classList.add("instance-icon");
      const icon = createIcon(firstInstance.type);
      groupicon.appendChild(icon);
      groupHeader.appendChild(groupicon);
      let groupNameHtml = "";
      groupNameHtml += name;
      groupNameHtml += ` <span class="group-counter">${group.length}</span>`;
      if (groupName && typeof groupName.innerHTML !== "undefined") {
        groupName.innerHTML = groupNameHtml;
      } else {
        console.error(
          "displayGroups: failed to set groupName.innerHTML, groupName is",
          groupName
        );
      }
      const selectAllContainer = document.createElement("span");
      selectAllContainer.classList.add("select-all-container");
      const selectAllLink = document.createElement("a");
      selectAllLink.href = "#";
      selectAllLink.classList.add("select-all-link");
      selectAllLink.title = "Select all";
      const svgIcon = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      svgIcon.setAttribute("width", "20");
      svgIcon.setAttribute("height", "20");
      svgIcon.innerHTML = '<use xlink:href="#select-all-icon"></use>';
      selectAllLink.appendChild(svgIcon);
      selectAllLink.style.visibility = "hidden";
      selectAllLink.style.marginLeft = "auto";
      selectAllLink.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const nodeIds = group.map((item) => item.nodeId);
        parent.postMessage(
          {
            pluginMessage: {
              type: "select-nodes",
              nodeIds
            }
          },
          "*"
        );
      });
      selectAllContainer.appendChild(selectAllLink);
      groupName.appendChild(selectAllContainer);
      groupHeader.appendChild(groupName);
      groupHeader.addEventListener("mouseenter", () => {
        selectAllLink.style.visibility = "visible";
      });
      groupHeader.addEventListener("mouseleave", () => {
        selectAllLink.style.visibility = "hidden";
      });
      const versionsInGroup = group.map((item) => item.nodeVersion || "      ");
      const libraryVersionsInGroup = group.map(
        (item) => item.libraryComponentVersion || "      "
      );
      const uniqueVersions = [...new Set(versionsInGroup)];
      const uniqueLibraryVersions = [...new Set(libraryVersionsInGroup)];
      const hasOutdatedItems = group.some((item) => item.isOutdated);
      const versionGroupHeader = displayVersionTag({
        uniqueVersions,
        libraryVersion: uniqueLibraryVersions[0],
        isGroupHeader: true,
        isOutdated: hasOutdatedItems,
        groupItems: group,
        tabType
      });
      if (versionGroupHeader) {
        groupHeader.appendChild(versionGroupHeader);
      } else {
        console.warn(
          "displayGroups: versionGroupHeader is empty for group",
          name
        );
      }
      targetList.appendChild(groupHeader);
      const groupItems = document.createElement("ul");
      groupItems.classList.add("group-items");
      group.forEach((instance) => {
        var _a, _b, _c;
        const groupItem = document.createElement("li");
        const componentNameContainer = document.createElement("div");
        componentNameContainer.classList.add("component-name-container");
        componentNameContainer.style.display = "flex";
        componentNameContainer.style.alignItems = "right";
        const itemIcon = createIcon(instance.type);
        componentNameContainer.insertBefore(
          itemIcon,
          componentNameContainer.firstChild
        );
        itemIcon.addEventListener("click", (e) => {
          e.stopPropagation();
          parent.postMessage(
            {
              pluginMessage: {
                type: "scroll-to-node",
                nodeId: instance.nodeId
              }
            },
            "*"
          );
        });
        itemIcon.addEventListener("mouseenter", () => {
          showPopover(itemIcon, instance);
        });
        const nameLink = document.createElement("a");
        nameLink.href = "#";
        nameLink.classList.add("component-link");
        nameLink.textContent = instance.name || "\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F";
        nameLink.addEventListener("click", (e) => {
          e.preventDefault();
          parent.postMessage(
            {
              pluginMessage: {
                type: "scroll-to-node",
                nodeId: instance.nodeId
                // Передаем nodeId инстанса
              }
            },
            "*"
          );
        });
        componentNameContainer.appendChild(nameLink);
        if (instance.parentName) {
          const parentName = document.createElement("span");
          parentName.classList.add("parent-component-name");
          parentName.textContent = "in " + instance.parentName;
          componentNameContainer.appendChild(parentName);
        }
        if (instance.hidden) {
          const hiddenLabel = document.createElement("span");
          hiddenLabel.classList.add("hidden-label");
          hiddenLabel.textContent = "hidden";
          componentNameContainer.appendChild(hiddenLabel);
        }
        groupItem.appendChild(componentNameContainer);
        const versionGroup = displayVersionTag({
          instanceVersion: (_a = instance.nodeVersion) != null ? _a : void 0,
          libraryVersion: (_b = instance.libraryComponentVersion) != null ? _b : void 0,
          isOutdated: instance.isOutdated,
          checkVersion: (_c = instance.checkVersion) != null ? _c : void 0,
          tabType
        });
        if (versionGroup) {
          componentNameContainer.appendChild(versionGroup);
        }
        groupItems.appendChild(groupItem);
      });
      targetList.appendChild(groupItems);
      groupHeader.addEventListener("click", () => {
        groupItems.classList.toggle("expanded");
      });
    }
  };
  if (typeof window !== "undefined") {
    window.UIModules = window.UIModules || {};
    window.UIModules.displayGroups = displayGroups;
  }
})();

"use strict";
(() => {
  // src/ui/createIcon.ts
  var createIcon = (type) => {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    let iconClass = "info-icon";
    let iconId = "info-icon";
    switch (type) {
      case "INSTANCE":
        iconClass = "instance-icon";
        iconId = "instance-icon";
        break;
      case "TEXT":
        iconClass = "text-icon";
        iconId = "text-icon";
        break;
      case "FRAME":
        iconClass = "frame-icon";
        iconId = "frame-icon";
        break;
      case "RECTANGLE":
        iconClass = "rectangle-icon";
        iconId = "rectangle-icon";
        break;
      case "VECTOR":
        iconClass = "frame-icon";
        iconId = "frame-icon";
        break;
    }
    svg.classList.add(iconClass);
    const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
    use.setAttributeNS("http://www.w3.org/1999/xlink", "href", `#${iconId}`);
    svg.appendChild(use);
    return svg;
  };

  // src/ui/showPopover.ts
  var showPopover = (icon, instance) => {
    const popover = document.createElement("div");
    popover.classList.add("popover");
    const content = Object.entries(instance).map(([key, value]) => {
      const boldKey = `<strong>${key}:</strong>`;
      if (typeof value === "object" && value !== null) {
        try {
          return `${boldKey} ${JSON.stringify(value)}`;
        } catch (e) {
          return `${boldKey} [object]`;
        }
      }
      return `${boldKey} ${value}`;
    }).join("<br>");
    popover.innerHTML = content;
    const maxWidth = Math.min(500, window.innerWidth - 40);
    const maxHeight = window.innerHeight - 40;
    popover.style.maxWidth = `${maxWidth}px`;
    popover.style.maxHeight = `${maxHeight}px`;
    popover.style.overflowY = "auto";
    popover.style.wordWrap = "break-word";
    document.body.appendChild(popover);
    const rect = icon.getBoundingClientRect();
    popover.style.visibility = "hidden";
    popover.style.display = "block";
    const popoverRect = popover.getBoundingClientRect();
    popover.style.display = "none";
    popover.style.visibility = "visible";
    let top = rect.bottom + 5;
    let left = rect.left;
    if (left + popoverRect.width > window.innerWidth - 10) {
      left = window.innerWidth - popoverRect.width - 10;
    }
    if (left < 10) {
      left = 10;
    }
    if (top + popoverRect.height > window.innerHeight - 10) {
      top = rect.top - popoverRect.height - 5;
    }
    if (top < 10) {
      top = 10;
    }
    popover.style.left = `${left}px`;
    popover.style.top = `${top}px`;
    popover.style.display = "block";
    const onLeave = () => {
      popover.remove();
      try {
        icon.removeEventListener("mouseleave", onLeave);
      } catch (e) {
      }
    };
    icon.addEventListener("mouseleave", onLeave);
  };

  // src/ui/displayColorsTab.ts
  var displayColorsTab = (groupedData, targetList) => {
    var _a;
    targetList.innerHTML = "";
    let headerText = "";
    if (!targetList || !targetList.id) {
      console.error("Target list or its ID is undefined.");
      return;
    }
    if (targetList.id === "colorResultsList") headerText = "Fill";
    if (targetList.id === "colorStrokeResultsList") headerText = "Stroke";
    if (headerText) {
      const prevHeader = targetList.previousElementSibling;
      if (prevHeader && prevHeader.classList.contains("section-header")) {
        prevHeader.remove();
      }
      const header = document.createElement("div");
      header.className = "section-header";
      header.textContent = headerText;
      (_a = targetList.parentNode) == null ? void 0 : _a.insertBefore(header, targetList);
    }
    for (const key in groupedData) {
      const group = groupedData[key];
      if (group.length === 0) continue;
      const firstInstance = group[0];
      const groupHeader = document.createElement("ul");
      groupHeader.classList.add("group-header");
      const groupName = document.createElement("div");
      groupName.classList.add("group-name");
      if (targetList.id === "colorResultsList") {
        const fillSwatch = document.createElement("div");
        fillSwatch.classList.add("group-color-icon");
        fillSwatch.style.backgroundColor = firstInstance.fill || "";
        if (firstInstance.fill_collection_name === "2" || firstInstance.fill_collection_name === "Color Styles") {
          fillSwatch.style.borderRadius = "999px";
        }
        groupHeader.appendChild(fillSwatch);
      } else if (targetList.id === "colorStrokeResultsList") {
        const strokeSwatch = document.createElement("div");
        strokeSwatch.classList.add("group-color-icon");
        strokeSwatch.style.backgroundColor = firstInstance.stroke || "";
        if (firstInstance.stroke_collection_name === "2" || firstInstance.stroke_collection_name === "Color Styles") {
          strokeSwatch.style.borderRadius = "999px";
        }
        groupHeader.appendChild(strokeSwatch);
      }
      let groupNameHtml = "";
      if (targetList.id === "colorResultsList") {
        groupNameHtml += firstInstance.fill_variable_name ? firstInstance.fill_variable_name : firstInstance.fill;
        groupNameHtml += firstInstance.fill_collection_name ? `<span style="font-weight:300">&nbsp;from ${firstInstance.fill_collection_name}&nbsp;</span>` : "";
      } else if (targetList.id === "colorStrokeResultsList") {
        groupNameHtml += firstInstance.stroke_variable_name ? firstInstance.stroke_variable_name : firstInstance.stroke;
        groupNameHtml += firstInstance.stroke_collection_name ? `<span style="font-weight:300">&nbsp;from ${firstInstance.stroke_collection_name}&nbsp;</span>` : "";
      }
      groupNameHtml += ` <span class="group-counter">${group.length}</span>`;
      groupName.innerHTML = groupNameHtml;
      const selectAllContainer = document.createElement("span");
      selectAllContainer.classList.add("select-all-container");
      const selectAllLink = document.createElement("a");
      selectAllLink.href = "#";
      selectAllLink.classList.add("select-all-link");
      selectAllLink.title = "Select all";
      const svgIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svgIcon.setAttribute("width", "20");
      svgIcon.setAttribute("height", "20");
      svgIcon.innerHTML = '<use xlink:href="#select-all-icon"></use>';
      selectAllLink.appendChild(svgIcon);
      selectAllLink.style.visibility = "hidden";
      selectAllLink.style.marginLeft = "auto";
      selectAllLink.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const nodeIds = group.map((item) => item.nodeId);
        parent.postMessage({
          pluginMessage: {
            type: "select-nodes",
            nodeIds
          }
        }, "*");
      });
      selectAllContainer.appendChild(selectAllLink);
      groupName.appendChild(selectAllContainer);
      groupHeader.appendChild(groupName);
      groupHeader.addEventListener("mouseenter", () => {
        selectAllLink.style.visibility = "visible";
      });
      groupHeader.addEventListener("mouseleave", () => {
        selectAllLink.style.visibility = "hidden";
      });
      targetList.appendChild(groupHeader);
      const groupItems = document.createElement("ul");
      groupItems.classList.add("group-items");
      group.forEach((instance) => {
        const groupItem = document.createElement("li");
        const componentNameContainer = document.createElement("div");
        componentNameContainer.classList.add("component-name-container");
        componentNameContainer.style.display = "flex";
        componentNameContainer.style.alignItems = "right";
        const itemIcon = createIcon(instance.type);
        componentNameContainer.insertBefore(itemIcon, componentNameContainer.firstChild);
        itemIcon.addEventListener("click", (e) => {
          e.stopPropagation();
          parent.postMessage(
            {
              pluginMessage: {
                type: "scroll-to-node",
                nodeId: instance.nodeId
              }
            },
            "*"
          );
        });
        itemIcon.addEventListener("mouseenter", () => {
          showPopover(itemIcon, instance);
        });
        const nameLink = document.createElement("a");
        nameLink.href = "#";
        nameLink.classList.add("component-link");
        nameLink.textContent = instance.name || "\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F";
        nameLink.addEventListener("click", (e) => {
          e.preventDefault();
          parent.postMessage(
            {
              pluginMessage: {
                type: "scroll-to-node",
                nodeId: instance.nodeId
                // Передаем nodeId инстанса
              }
            },
            "*"
          );
        });
        componentNameContainer.appendChild(nameLink);
        if (instance.parentName) {
          const parentName = document.createElement("span");
          parentName.classList.add("parent-component-name");
          parentName.textContent = "in " + instance.parentName;
          componentNameContainer.appendChild(parentName);
        }
        if (instance.hidden) {
          const hiddenLabel = document.createElement("span");
          hiddenLabel.classList.add("hidden-label");
          hiddenLabel.textContent = "hidden";
          componentNameContainer.appendChild(hiddenLabel);
        }
        if (instance.color) {
          groupItem.appendChild(componentNameContainer);
          if (instance.fill) {
            const fillContainer = document.createElement("div");
            fillContainer.style.display = "flex";
            fillContainer.style.alignItems = "center";
            fillContainer.style.marginTop = "0px";
            fillContainer.style.marginLeft = "0px";
            fillContainer.style.marginBottom = "4px";
            const fillSwatch = document.createElement("div");
            fillSwatch.style.width = "16px";
            fillSwatch.style.height = "16px";
            fillSwatch.style.backgroundColor = instance.fill;
            if (instance.fill_collection_name === "2" || instance.fill_collection_name === "Color Styles") {
              fillSwatch.style.borderRadius = "999px";
            } else {
              fillSwatch.style.borderRadius = "4px";
            }
            fillSwatch.style.marginRight = "4px";
            fillSwatch.style.marginLeft = "00px";
            fillSwatch.style.border = "1px solid #ddd";
            const fillInfo = document.createElement("div");
            fillInfo.style.display = "flex";
            fillInfo.style.flexDirection = "row";
            fillInfo.style.gap = "4px";
            fillInfo.style.justifyContent = "space-between";
            fillInfo.style.width = "100%";
            groupItem.appendChild(componentNameContainer);
            const varInfo = document.createElement("span");
            const fillType = document.createElement("span");
            fillType.textContent = "Fill";
            fillType.style.color = "var(--text-light-color)";
            fillType.style.fontWeight = "300";
            fillType.style.marginLeft = "auto";
            fillType.style.fontSize = "var(--font-small)";
            const collectionName = document.createElement("span");
            if (instance.fill_variable_name) {
              varInfo.textContent = instance.fill_variable_name;
              varInfo.style.color = "var(--text-light-color)";
              varInfo.style.fontWeight = "400";
              if (instance.fill_collection_name) {
                collectionName.textContent = ` from ${instance.fill_collection_name}`;
                collectionName.style.color = "var(--text-light-color)";
                collectionName.style.fontWeight = "300";
              }
            } else {
              varInfo.textContent = instance.fill;
              varInfo.style.color = "var(--text-light-color)";
              varInfo.style.fontWeight = "400";
            }
            fillInfo.appendChild(varInfo);
            fillInfo.appendChild(collectionName);
            fillInfo.appendChild(fillType);
            groupItem.appendChild(fillContainer);
          }
          if (instance.stroke) {
            const collectionName = document.createElement("span");
            const strokeContainer = document.createElement("div");
            strokeContainer.style.display = "flex";
            strokeContainer.style.alignItems = "center";
            strokeContainer.style.marginTop = "0px";
            strokeContainer.style.marginLeft = "0px";
            strokeContainer.style.marginBottom = "4px";
            const strokeSwatch = document.createElement("div");
            strokeSwatch.style.width = "16px";
            strokeSwatch.style.height = "16px";
            strokeSwatch.style.backgroundColor = instance.stroke;
            if (instance.stroke_collection_name === "2" || instance.stroke_collection_name === "Color Styles") {
              strokeSwatch.style.borderRadius = "999px";
            } else {
              strokeSwatch.style.borderRadius = "3px";
            }
            strokeSwatch.style.marginRight = "8px";
            strokeSwatch.style.border = "1px solid #ddd";
            const strokeInfo = document.createElement("div");
            strokeInfo.style.display = "flex";
            strokeInfo.style.flexDirection = "row";
            strokeInfo.style.gap = "4px";
            strokeInfo.style.justifyContent = "space-between";
            strokeInfo.style.width = "100%";
            const varInfo = document.createElement("span");
            if (instance.stroke_variable_name) {
              varInfo.textContent = instance.stroke_variable_name;
              varInfo.style.color = "var(--text-light-color)";
              varInfo.style.fontWeight = "400";
              if (instance.stroke_collection_name) {
                collectionName.textContent = ` from ${instance.stroke_collection_name}`;
                collectionName.style.color = "var(--text-light-color)";
                collectionName.style.fontWeight = "300";
              }
            } else {
              varInfo.textContent = instance.stroke;
              varInfo.style.color = "var(--text-light-color)";
              varInfo.style.fontWeight = "400";
            }
            const strokeType = document.createElement("span");
            strokeType.textContent = "Stroke";
            strokeType.style.color = "var(--text-light-color)";
            strokeType.style.fontWeight = "300";
            strokeType.style.marginLeft = "auto";
            strokeType.style.fontSize = "var(--font-small)";
            strokeInfo.appendChild(varInfo);
            strokeInfo.appendChild(collectionName);
            strokeInfo.appendChild(strokeType);
            groupItem.appendChild(strokeContainer);
          }
        }
        groupItems.appendChild(groupItem);
      });
      targetList.appendChild(groupItems);
      groupHeader.addEventListener("click", () => {
        groupItems.classList.toggle("expanded");
      });
    }
  };
  if (typeof window !== "undefined") {
    window.UIModules = window.UIModules || {};
    window.UIModules.displayColorsTab = displayColorsTab;
  }
})();

"use strict";
(() => {
  // src/ui/createIcon.ts
  var createIcon = (type) => {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    let iconClass = "info-icon";
    let iconId = "info-icon";
    switch (type) {
      case "INSTANCE":
        iconClass = "instance-icon";
        iconId = "instance-icon";
        break;
      case "TEXT":
        iconClass = "text-icon";
        iconId = "text-icon";
        break;
      case "FRAME":
        iconClass = "frame-icon";
        iconId = "frame-icon";
        break;
      case "RECTANGLE":
        iconClass = "rectangle-icon";
        iconId = "rectangle-icon";
        break;
      case "VECTOR":
        iconClass = "frame-icon";
        iconId = "frame-icon";
        break;
    }
    svg.classList.add(iconClass);
    const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
    use.setAttributeNS("http://www.w3.org/1999/xlink", "href", `#${iconId}`);
    svg.appendChild(use);
    return svg;
  };

  // src/ui/showPopover.ts
  var showPopover = (icon, instance) => {
    const popover = document.createElement("div");
    popover.classList.add("popover");
    const content = Object.entries(instance).map(([key, value]) => {
      const boldKey = `<strong>${key}:</strong>`;
      if (typeof value === "object" && value !== null) {
        try {
          return `${boldKey} ${JSON.stringify(value)}`;
        } catch (e) {
          return `${boldKey} [object]`;
        }
      }
      return `${boldKey} ${value}`;
    }).join("<br>");
    popover.innerHTML = content;
    const maxWidth = Math.min(500, window.innerWidth - 40);
    const maxHeight = window.innerHeight - 40;
    popover.style.maxWidth = `${maxWidth}px`;
    popover.style.maxHeight = `${maxHeight}px`;
    popover.style.overflowY = "auto";
    popover.style.wordWrap = "break-word";
    document.body.appendChild(popover);
    const rect = icon.getBoundingClientRect();
    popover.style.visibility = "hidden";
    popover.style.display = "block";
    const popoverRect = popover.getBoundingClientRect();
    popover.style.display = "none";
    popover.style.visibility = "visible";
    let top = rect.bottom + 5;
    let left = rect.left;
    if (left + popoverRect.width > window.innerWidth - 10) {
      left = window.innerWidth - popoverRect.width - 10;
    }
    if (left < 10) {
      left = 10;
    }
    if (top + popoverRect.height > window.innerHeight - 10) {
      top = rect.top - popoverRect.height - 5;
    }
    if (top < 10) {
      top = 10;
    }
    popover.style.left = `${left}px`;
    popover.style.top = `${top}px`;
    popover.style.display = "block";
    const onLeave = () => {
      popover.remove();
      try {
        icon.removeEventListener("mouseleave", onLeave);
      } catch (e) {
      }
    };
    icon.addEventListener("mouseleave", onLeave);
  };

  // src/ui/displayVersionTag.ts
  function displayVersionTag(options) {
    const {
      instanceVersion = "      ",
      libraryVersion = "      ",
      checkVersion = "",
      isGroupHeader = false,
      groupItems = [],
      tabType = ""
    } = options;
    if (tabType === "deprecated" || tabType === "detached" || tabType === "lost") {
      const emptyContainer = document.createElement("span");
      emptyContainer.classList.add("version-group");
      return emptyContainer;
    }
    const versionGroup = document.createElement("span");
    versionGroup.classList.add("version-group");
    const versionBadge = document.createElement("span");
    versionBadge.classList.add("version-tag");
    if (isGroupHeader && groupItems) {
      const latestCount = groupItems.filter(
        (item) => item.checkVersion === "Latest"
      ).length;
      const notLatestCount = groupItems.filter(
        (item) => item.checkVersion === "NotLatest"
      ).length;
      const outdatedCount = groupItems.filter(
        (item) => item.checkVersion === "Outdated"
      ).length;
      if (latestCount === 0 && notLatestCount === 0 && outdatedCount === 0) {
        return versionGroup;
      }
      if (outdatedCount > 0) {
        const outdatedBadge = document.createElement("span");
        outdatedBadge.classList.add("version-tag", "version-tag-outdated");
        outdatedBadge.textContent = outdatedCount.toString();
        versionGroup.appendChild(outdatedBadge);
      }
      if (notLatestCount > 0) {
        const notLatestBadge = document.createElement("span");
        notLatestBadge.classList.add("version-tag", "version-tag-notlatest");
        notLatestBadge.textContent = notLatestCount.toString();
        versionGroup.appendChild(notLatestBadge);
      }
      if (latestCount > 0) {
        const latestBadge = document.createElement("span");
        latestBadge.classList.add("version-tag", "version-tag-latest");
        latestBadge.textContent = latestCount.toString();
        versionGroup.appendChild(latestBadge);
      }
      return versionGroup;
    } else {
      const hasInstanceVersion = instanceVersion && instanceVersion !== "none";
      const hasLibraryVersion = libraryVersion && libraryVersion !== "none";
      if (!hasInstanceVersion && !hasLibraryVersion) {
        return versionGroup;
      }
      if (hasLibraryVersion && checkVersion !== "Latest") {
        versionBadge.textContent = `${instanceVersion || "none"} \u2192 ${libraryVersion}`;
        if (checkVersion === "NotLatest") {
          versionBadge.classList.add("version-tag-notlatest");
        }
        if (checkVersion === "Outdated") {
          versionBadge.classList.add("version-tag-outdated");
        }
      } else if (hasInstanceVersion) {
        versionBadge.textContent = instanceVersion;
        if (checkVersion === "Latest") {
          versionBadge.classList.add("version-tag-latest");
        }
      } else {
        return versionGroup;
      }
    }
    if (!isGroupHeader && versionBadge.textContent) {
      versionGroup.appendChild(versionBadge);
    }
    return versionGroup;
  }

  // src/ui/displayGroups.ts
  var displayGroups = (groupedData, targetList, tabType = "") => {
    targetList.innerHTML = "";
    if (!targetList || !targetList.id) {
      console.error("Target list or its ID is undefined.");
      return;
    }
    for (const key in groupedData) {
      const group = groupedData[key];
      if (group.length === 0) continue;
      const firstInstance = group[0];
      const name = firstInstance.mainComponentSetName ? firstInstance.mainComponentSetName : firstInstance.mainComponentName ? firstInstance.mainComponentName : firstInstance.name;
      const groupHeader = document.createElement("ul");
      groupHeader.classList.add("group-header");
      const groupName = document.createElement("div");
      groupName.classList.add("group-name");
      const groupicon = document.createElement("div");
      groupicon.classList.add("instance-icon");
      const icon = createIcon(firstInstance.type);
      groupicon.appendChild(icon);
      groupHeader.appendChild(groupicon);
      let groupNameHtml = "";
      groupNameHtml += name;
      groupNameHtml += ` <span class="group-counter">${group.length}</span>`;
      if (groupName && typeof groupName.innerHTML !== "undefined") {
        groupName.innerHTML = groupNameHtml;
      } else {
        console.error(
          "displayGroups: failed to set groupName.innerHTML, groupName is",
          groupName
        );
      }
      const selectAllContainer = document.createElement("span");
      selectAllContainer.classList.add("select-all-container");
      const selectAllLink = document.createElement("a");
      selectAllLink.href = "#";
      selectAllLink.classList.add("select-all-link");
      selectAllLink.title = "Select all";
      const svgIcon = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      svgIcon.setAttribute("width", "20");
      svgIcon.setAttribute("height", "20");
      svgIcon.innerHTML = '<use xlink:href="#select-all-icon"></use>';
      selectAllLink.appendChild(svgIcon);
      selectAllLink.style.visibility = "hidden";
      selectAllLink.style.marginLeft = "auto";
      selectAllLink.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const nodeIds = group.map((item) => item.nodeId);
        parent.postMessage(
          {
            pluginMessage: {
              type: "select-nodes",
              nodeIds
            }
          },
          "*"
        );
      });
      selectAllContainer.appendChild(selectAllLink);
      groupName.appendChild(selectAllContainer);
      groupHeader.appendChild(groupName);
      groupHeader.addEventListener("mouseenter", () => {
        selectAllLink.style.visibility = "visible";
      });
      groupHeader.addEventListener("mouseleave", () => {
        selectAllLink.style.visibility = "hidden";
      });
      const versionsInGroup = group.map((item) => item.nodeVersion || "      ");
      const libraryVersionsInGroup = group.map(
        (item) => item.libraryComponentVersion || "      "
      );
      const uniqueVersions = [...new Set(versionsInGroup)];
      const uniqueLibraryVersions = [...new Set(libraryVersionsInGroup)];
      const hasOutdatedItems = group.some((item) => item.isOutdated);
      const versionGroupHeader = displayVersionTag({
        uniqueVersions,
        libraryVersion: uniqueLibraryVersions[0],
        isGroupHeader: true,
        isOutdated: hasOutdatedItems,
        groupItems: group,
        tabType
      });
      if (versionGroupHeader) {
        groupHeader.appendChild(versionGroupHeader);
      } else {
        console.warn(
          "displayGroups: versionGroupHeader is empty for group",
          name
        );
      }
      targetList.appendChild(groupHeader);
      const groupItems = document.createElement("ul");
      groupItems.classList.add("group-items");
      group.forEach((instance) => {
        var _a, _b, _c;
        const groupItem = document.createElement("li");
        const componentNameContainer = document.createElement("div");
        componentNameContainer.classList.add("component-name-container");
        componentNameContainer.style.display = "flex";
        componentNameContainer.style.alignItems = "right";
        const itemIcon = createIcon(instance.type);
        componentNameContainer.insertBefore(
          itemIcon,
          componentNameContainer.firstChild
        );
        itemIcon.addEventListener("click", (e) => {
          e.stopPropagation();
          parent.postMessage(
            {
              pluginMessage: {
                type: "scroll-to-node",
                nodeId: instance.nodeId
              }
            },
            "*"
          );
        });
        itemIcon.addEventListener("mouseenter", () => {
          showPopover(itemIcon, instance);
        });
        const nameLink = document.createElement("a");
        nameLink.href = "#";
        nameLink.classList.add("component-link");
        nameLink.textContent = instance.name || "\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F";
        nameLink.addEventListener("click", (e) => {
          e.preventDefault();
          parent.postMessage(
            {
              pluginMessage: {
                type: "scroll-to-node",
                nodeId: instance.nodeId
                // Передаем nodeId инстанса
              }
            },
            "*"
          );
        });
        componentNameContainer.appendChild(nameLink);
        if (instance.parentName) {
          const parentName = document.createElement("span");
          parentName.classList.add("parent-component-name");
          parentName.textContent = "in " + instance.parentName;
          componentNameContainer.appendChild(parentName);
        }
        if (instance.hidden) {
          const hiddenLabel = document.createElement("span");
          hiddenLabel.classList.add("hidden-label");
          hiddenLabel.textContent = "hidden";
          componentNameContainer.appendChild(hiddenLabel);
        }
        groupItem.appendChild(componentNameContainer);
        const versionGroup = displayVersionTag({
          instanceVersion: (_a = instance.nodeVersion) != null ? _a : void 0,
          libraryVersion: (_b = instance.libraryComponentVersion) != null ? _b : void 0,
          isOutdated: instance.isOutdated,
          checkVersion: (_c = instance.checkVersion) != null ? _c : void 0,
          tabType
        });
        if (versionGroup) {
          componentNameContainer.appendChild(versionGroup);
        }
        groupItems.appendChild(groupItem);
      });
      targetList.appendChild(groupItems);
      groupHeader.addEventListener("click", () => {
        groupItems.classList.toggle("expanded");
      });
    }
  };
  if (typeof window !== "undefined") {
    window.UIModules = window.UIModules || {};
    window.UIModules.displayGroups = displayGroups;
  }

  // src/ui/sortGroups.ts
  function sortGroups(groups) {
    return Object.fromEntries(
      Object.entries(groups).sort(([, groupAItems], [, groupBItems]) => {
        const firstItemA = groupAItems[0];
        const firstItemB = groupBItems[0];
        const aName = (firstItemA.mainComponentSetName || firstItemA.mainComponentName || firstItemA.name || "").replace(/([\u0023-\u0039]\uFE0F?\u20E3|\u00A9|\u00AE|[\u2000-\u3300]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|\uD83E[\uDC00-\uDFFF])/gu, "").trim().replace(/^[^a-zA-Z0-9\/]+/, "");
        const bName = (firstItemB.mainComponentSetName || firstItemB.mainComponentName || firstItemB.name || "").replace(/([\u0023-\u0039]\uFE0F?\u20E3|\u00A9|\u00AE|[\u2000-\u3300]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|\uD83E[\uDC00-\uDFFF])/gu, "").trim().replace(/^[^a-zA-Z0-9\/]+/, "");
        const aSpecial = /^[._]/.test(aName);
        const bSpecial = /^[._]/.test(bName);
        if (aSpecial && !bSpecial) return 1;
        if (!aSpecial && bSpecial) return -1;
        return aName.localeCompare(bName, void 0, { numeric: true, sensitivity: "accent" });
      })
    );
  }

  // src/js/component/processDetachedFrame.ts
  function filterDetachedFrames(instances) {
    return instances.filter((instance) => {
      return instance.isDetached === true;
    });
  }

  // src/ui/processAndDisplayComponents.ts
  function processAndDisplayComponents(componentsData, allInstances, resultsList, iconResultsList, tabType = "instances") {
    let sourceInstances;
    if (tabType === "outdated") {
      if (componentsData.outdated && componentsData.outdated.length > 0) {
        sourceInstances = componentsData.outdated;
      } else {
        sourceInstances = componentsData.instances.filter(
          (instance) => instance.checkVersion === "Outdated"
        );
      }
    } else if (tabType === "lost") {
      if (componentsData.lost && componentsData.lost.length > 0) {
        sourceInstances = componentsData.lost;
      } else {
        sourceInstances = componentsData.instances.filter(
          (instance) => instance.isLost === true
        );
      }
    } else if (tabType === "deprecated") {
      if (componentsData.deprecated && componentsData.deprecated.length > 0) {
        sourceInstances = componentsData.deprecated;
      } else {
        sourceInstances = componentsData.instances.filter(
          (instance) => instance.isDeprecated === true
        );
      }
    } else if (tabType === "detached") {
      sourceInstances = componentsData.instances.filter((instance) => {
        const isDetached = instance.isDetached === true;
        return isDetached;
      });
    } else {
      sourceInstances = componentsData.instances;
    }
    allInstances = sourceInstances;
    const groupedInstances = {};
    const groupedIcons = {};
    const showHiddenToggle = document.getElementById(
      "showHiddenToggle"
    );
    const showHidden = showHiddenToggle ? showHiddenToggle.checked : true;
    let nonIconCount = 0;
    let iconCount = 0;
    let outdatedCount = componentsData.counts && typeof componentsData.counts.outdated === "number" ? componentsData.counts.outdated : componentsData.outdated ? componentsData.outdated.length : 0;
    let lostCount = componentsData.counts && typeof componentsData.counts.lost === "number" ? componentsData.counts.lost : componentsData.lost ? componentsData.lost.length : 0;
    let deprecatedCount = componentsData.counts && typeof componentsData.counts.deprecated === "number" ? componentsData.counts.deprecated : componentsData.deprecated ? componentsData.deprecated.length : 0;
    const detachedCount = componentsData.counts && typeof componentsData.counts.detached === "number" ? componentsData.counts.detached : filterDetachedFrames(componentsData.instances).length;
    sourceInstances.forEach((instance) => {
      if (!showHidden && instance.hidden) {
        return;
      }
      if (tabType === "outdated" && instance.checkVersion !== "Outdated") {
        return;
      }
      if (tabType === "lost" && instance.isLost !== true) {
        return;
      }
      if (tabType === "deprecated" && instance.isDeprecated !== true) {
        return;
      }
      if (tabType === "detached" && !instance.isDetached) {
        return;
      }
      if (tabType === "instances" && instance.isDetached) {
        return;
      }
      const groupKey = tabType === "detached" ? instance.name || "Unknown" : instance.mainComponentSetKey ? instance.mainComponentSetKey : instance.mainComponentKey || "Unknown";
      if (tabType === "outdated" || tabType === "lost" || tabType === "deprecated" || tabType === "detached") {
        if (!groupedInstances[groupKey]) {
          groupedInstances[groupKey] = [];
        }
        const existingInstance = groupedInstances[groupKey].find(
          (existing) => existing.nodeId === instance.nodeId
        );
        if (existingInstance) {
          return;
        }
        groupedInstances[groupKey].push(instance);
        nonIconCount++;
      } else if (instance.isIcon === true) {
        if (!groupedIcons[groupKey]) {
          groupedIcons[groupKey] = [];
        }
        groupedIcons[groupKey].push(instance);
        iconCount++;
      } else {
        if (!groupedInstances[groupKey]) {
          groupedInstances[groupKey] = [];
        }
        const existingInstance = groupedInstances[groupKey].find(
          (existing) => existing.nodeId === instance.nodeId
        );
        if (existingInstance) {
          return;
        }
        groupedInstances[groupKey].push(instance);
        nonIconCount++;
      }
    });
    const parseVersionNumbers = (v) => {
      if (!v || typeof v !== "string") return null;
      const m = v.trim().replace(/^v\s*/i, "").match(/(\d+)(?:\.(\d+))?(?:\.(\d+))?/);
      if (!m) return null;
      return [Number(m[1] || 0), Number(m[2] || 0), Number(m[3] || 0)];
    };
    const compareByVersionThenName = (a, b) => {
      const aVer = parseVersionNumbers(a.nodeVersion || "");
      const bVer = parseVersionNumbers(b.nodeVersion || "");
      if (aVer && bVer) {
        for (let i = 0; i < 3; i++) {
          if ((aVer[i] || 0) < (bVer[i] || 0)) return -1;
          if ((aVer[i] || 0) > (bVer[i] || 0)) return 1;
        }
      } else if (aVer && !bVer) {
        return -1;
      } else if (!aVer && bVer) {
        return 1;
      }
      const aName = (a.name || "").toString();
      const bName = (b.name || "").toString();
      return aName.localeCompare(bName);
    };
    const compareByName = (a, b) => {
      const aName = a.name || "";
      const bName = b.name || "";
      return aName.localeCompare(bName);
    };
    const sortFunction = tabType === "outdated" || tabType === "lost" || tabType === "deprecated" || tabType === "detached" ? compareByName : compareByVersionThenName;
    for (const key in groupedInstances) {
      groupedInstances[key].sort(sortFunction);
    }
    for (const key in groupedIcons) {
      groupedIcons[key].sort(sortFunction);
    }
    if (tabType === "outdated") {
      outdatedCount = nonIconCount;
    }
    if (tabType === "lost") {
      lostCount = nonIconCount;
    }
    if (tabType === "deprecated") {
      deprecatedCount = nonIconCount;
    }
    const allSubTab = document.querySelector(
      '.tab_borderless[data-tab="instances"]'
    );
    const iconsTab = document.querySelector('[data-tab="icons"]');
    const outdatedTab = document.querySelector('[data-tab="outdated"]');
    const lostTab = document.querySelector('[data-tab="lost"]');
    const deprecatedTab = document.querySelector('[data-tab="deprecated"]');
    if (tabType === "instances") {
      if (allSubTab) {
        allSubTab.textContent = `All (${nonIconCount + iconCount})`;
        if (nonIconCount + iconCount === 0) {
          allSubTab.classList.remove("tab_borderless");
          allSubTab.classList.add("tab_borderless_disabled");
          allSubTab.style.pointerEvents = "none";
        } else {
          allSubTab.classList.remove("tab_borderless_disabled");
          allSubTab.classList.add("tab_borderless");
          allSubTab.style.pointerEvents = "auto";
        }
      }
      if (iconsTab) {
        iconsTab.textContent = `Icons (${iconCount})`;
        if (iconCount === 0) {
          iconsTab.classList.remove("tab_borderless");
          iconsTab.classList.add("tab_borderless_disabled");
          iconsTab.style.pointerEvents = "none";
        } else {
          iconsTab.classList.remove("tab_borderless_disabled");
          iconsTab.classList.add("tab_borderless");
          iconsTab.style.pointerEvents = "auto";
        }
      }
    } else if (tabType === "outdated") {
      if (outdatedTab) {
        outdatedTab.textContent = `Outdated (${outdatedCount})`;
        if (outdatedCount === 0) {
          outdatedTab.classList.remove("tab_borderless");
          outdatedTab.classList.add("tab_borderless_disabled");
          outdatedTab.style.pointerEvents = "none";
        } else {
          outdatedTab.classList.remove("tab_borderless_disabled");
          outdatedTab.classList.add("tab_borderless");
          outdatedTab.style.pointerEvents = "auto";
        }
      }
    } else if (tabType === "lost") {
      if (lostTab) {
        lostTab.textContent = `Lost (${lostCount})`;
        if (lostCount === 0) {
          lostTab.classList.remove("tab_borderless");
          lostTab.classList.add("tab_borderless_disabled");
          lostTab.style.pointerEvents = "none";
        } else {
          lostTab.classList.remove("tab_borderless_disabled");
          lostTab.classList.add("tab_borderless");
          lostTab.style.pointerEvents = "auto";
        }
      }
    } else if (tabType === "deprecated") {
      if (deprecatedTab) {
        deprecatedTab.textContent = `Deprecated (${deprecatedCount})`;
        if (deprecatedCount === 0) {
          deprecatedTab.classList.remove("tab_borderless");
          deprecatedTab.classList.add("tab_borderless_disabled");
          deprecatedTab.style.pointerEvents = "none";
        } else {
          deprecatedTab.classList.remove("tab_borderless_disabled");
          deprecatedTab.classList.add("tab_borderless");
          deprecatedTab.style.pointerEvents = "auto";
        }
      }
    } else if (tabType === "detached") {
      const detachedTab = document.querySelector('[data-tab="detached"]');
      if (detachedTab) {
        detachedTab.textContent = `Detached (${detachedCount})`;
        if (detachedCount === 0) {
          detachedTab.classList.remove("tab_borderless");
          detachedTab.classList.add("tab_borderless_disabled");
          detachedTab.style.pointerEvents = "none";
        } else {
          detachedTab.classList.remove("tab_borderless_disabled");
          detachedTab.classList.add("tab_borderless");
          detachedTab.style.pointerEvents = "auto";
        }
      }
    }
    if (tabType === "outdated" || tabType === "lost" || tabType === "deprecated" || tabType === "detached") {
      displayGroups(sortGroups(groupedInstances), resultsList, tabType);
      if (iconResultsList) {
        iconResultsList.innerHTML = "";
      }
    } else {
      displayGroups(sortGroups(groupedInstances), resultsList, tabType);
      if (iconResultsList) {
        displayGroups(sortGroups(groupedIcons), iconResultsList, tabType);
      }
    }
    updateErrorsTabHeader();
  }
  function updateErrorsTabHeader() {
    const errorsTab = document.querySelector('[data-tab="errorsTab"]');
    if (!errorsTab) return;
    const colorsTab = document.querySelector('[data-tab="colors"]');
    const outdatedTab = document.querySelector('[data-tab="outdated"]');
    const lostTab = document.querySelector('[data-tab="lost"]');
    const deprecatedTab = document.querySelector('[data-tab="deprecated"]');
    const detachedTab = document.querySelector('[data-tab="detached"]');
    const extractCount = (tab) => {
      if (!tab || !tab.textContent) return 0;
      const match = tab.textContent.match(/\((\d+)\)/);
      return match ? parseInt(match[1], 10) : 0;
    };
    const colorsCount = extractCount(colorsTab);
    const outdatedCount = extractCount(outdatedTab);
    const lostCount = extractCount(lostTab);
    const deprecatedCount = extractCount(deprecatedTab);
    const detachedCount = extractCount(detachedTab);
    const totalErrorsCount = colorsCount + outdatedCount + lostCount + deprecatedCount + detachedCount;
    errorsTab.textContent = `Errors (${totalErrorsCount})`;
    if (totalErrorsCount === 0) {
      errorsTab.classList.add("disabled");
      errorsTab.style.pointerEvents = "none";
    } else {
      errorsTab.classList.remove("disabled");
      errorsTab.style.pointerEvents = "auto";
    }
  }
  if (typeof window !== "undefined") {
    window.UIModules = window.UIModules || {};
    window.UIModules.processAndDisplayComponents = processAndDisplayComponents;
    window.UIModules.updateErrorsTabHeader = updateErrorsTabHeader;
  }
})();

"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };

  // src/ui/createIcon.ts
  var createIcon = (type) => {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    let iconClass = "info-icon";
    let iconId = "info-icon";
    switch (type) {
      case "INSTANCE":
        iconClass = "instance-icon";
        iconId = "instance-icon";
        break;
      case "TEXT":
        iconClass = "text-icon";
        iconId = "text-icon";
        break;
      case "FRAME":
        iconClass = "frame-icon";
        iconId = "frame-icon";
        break;
      case "RECTANGLE":
        iconClass = "rectangle-icon";
        iconId = "rectangle-icon";
        break;
      case "VECTOR":
        iconClass = "frame-icon";
        iconId = "frame-icon";
        break;
    }
    svg.classList.add(iconClass);
    const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
    use.setAttributeNS("http://www.w3.org/1999/xlink", "href", `#${iconId}`);
    svg.appendChild(use);
    return svg;
  };

  // src/ui/showPopover.ts
  var showPopover = (icon, instance) => {
    const popover = document.createElement("div");
    popover.classList.add("popover");
    const content = Object.entries(instance).map(([key, value]) => {
      const boldKey = `<strong>${key}:</strong>`;
      if (typeof value === "object" && value !== null) {
        try {
          return `${boldKey} ${JSON.stringify(value)}`;
        } catch (e) {
          return `${boldKey} [object]`;
        }
      }
      return `${boldKey} ${value}`;
    }).join("<br>");
    popover.innerHTML = content;
    const maxWidth = Math.min(500, window.innerWidth - 40);
    const maxHeight = window.innerHeight - 40;
    popover.style.maxWidth = `${maxWidth}px`;
    popover.style.maxHeight = `${maxHeight}px`;
    popover.style.overflowY = "auto";
    popover.style.wordWrap = "break-word";
    document.body.appendChild(popover);
    const rect = icon.getBoundingClientRect();
    popover.style.visibility = "hidden";
    popover.style.display = "block";
    const popoverRect = popover.getBoundingClientRect();
    popover.style.display = "none";
    popover.style.visibility = "visible";
    let top = rect.bottom + 5;
    let left = rect.left;
    if (left + popoverRect.width > window.innerWidth - 10) {
      left = window.innerWidth - popoverRect.width - 10;
    }
    if (left < 10) {
      left = 10;
    }
    if (top + popoverRect.height > window.innerHeight - 10) {
      top = rect.top - popoverRect.height - 5;
    }
    if (top < 10) {
      top = 10;
    }
    popover.style.left = `${left}px`;
    popover.style.top = `${top}px`;
    popover.style.display = "block";
    const onLeave = () => {
      popover.remove();
      try {
        icon.removeEventListener("mouseleave", onLeave);
      } catch (e) {
      }
    };
    icon.addEventListener("mouseleave", onLeave);
  };

  // src/ui/displayColorsTab.ts
  var displayColorsTab = (groupedData, targetList) => {
    var _a;
    targetList.innerHTML = "";
    let headerText = "";
    if (!targetList || !targetList.id) {
      console.error("Target list or its ID is undefined.");
      return;
    }
    if (targetList.id === "colorResultsList") headerText = "Fill";
    if (targetList.id === "colorStrokeResultsList") headerText = "Stroke";
    if (headerText) {
      const prevHeader = targetList.previousElementSibling;
      if (prevHeader && prevHeader.classList.contains("section-header")) {
        prevHeader.remove();
      }
      const header = document.createElement("div");
      header.className = "section-header";
      header.textContent = headerText;
      (_a = targetList.parentNode) == null ? void 0 : _a.insertBefore(header, targetList);
    }
    for (const key in groupedData) {
      const group = groupedData[key];
      if (group.length === 0) continue;
      const firstInstance = group[0];
      const groupHeader = document.createElement("ul");
      groupHeader.classList.add("group-header");
      const groupName = document.createElement("div");
      groupName.classList.add("group-name");
      if (targetList.id === "colorResultsList") {
        const fillSwatch = document.createElement("div");
        fillSwatch.classList.add("group-color-icon");
        fillSwatch.style.backgroundColor = firstInstance.fill || "";
        if (firstInstance.fill_collection_name === "2" || firstInstance.fill_collection_name === "Color Styles") {
          fillSwatch.style.borderRadius = "999px";
        }
        groupHeader.appendChild(fillSwatch);
      } else if (targetList.id === "colorStrokeResultsList") {
        const strokeSwatch = document.createElement("div");
        strokeSwatch.classList.add("group-color-icon");
        strokeSwatch.style.backgroundColor = firstInstance.stroke || "";
        if (firstInstance.stroke_collection_name === "2" || firstInstance.stroke_collection_name === "Color Styles") {
          strokeSwatch.style.borderRadius = "999px";
        }
        groupHeader.appendChild(strokeSwatch);
      }
      let groupNameHtml = "";
      if (targetList.id === "colorResultsList") {
        groupNameHtml += firstInstance.fill_variable_name ? firstInstance.fill_variable_name : firstInstance.fill;
        groupNameHtml += firstInstance.fill_collection_name ? `<span style="font-weight:300">&nbsp;from ${firstInstance.fill_collection_name}&nbsp;</span>` : "";
      } else if (targetList.id === "colorStrokeResultsList") {
        groupNameHtml += firstInstance.stroke_variable_name ? firstInstance.stroke_variable_name : firstInstance.stroke;
        groupNameHtml += firstInstance.stroke_collection_name ? `<span style="font-weight:300">&nbsp;from ${firstInstance.stroke_collection_name}&nbsp;</span>` : "";
      }
      groupNameHtml += ` <span class="group-counter">${group.length}</span>`;
      groupName.innerHTML = groupNameHtml;
      const selectAllContainer = document.createElement("span");
      selectAllContainer.classList.add("select-all-container");
      const selectAllLink = document.createElement("a");
      selectAllLink.href = "#";
      selectAllLink.classList.add("select-all-link");
      selectAllLink.title = "Select all";
      const svgIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svgIcon.setAttribute("width", "20");
      svgIcon.setAttribute("height", "20");
      svgIcon.innerHTML = '<use xlink:href="#select-all-icon"></use>';
      selectAllLink.appendChild(svgIcon);
      selectAllLink.style.visibility = "hidden";
      selectAllLink.style.marginLeft = "auto";
      selectAllLink.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const nodeIds = group.map((item) => item.nodeId);
        parent.postMessage({
          pluginMessage: {
            type: "select-nodes",
            nodeIds
          }
        }, "*");
      });
      selectAllContainer.appendChild(selectAllLink);
      groupName.appendChild(selectAllContainer);
      groupHeader.appendChild(groupName);
      groupHeader.addEventListener("mouseenter", () => {
        selectAllLink.style.visibility = "visible";
      });
      groupHeader.addEventListener("mouseleave", () => {
        selectAllLink.style.visibility = "hidden";
      });
      targetList.appendChild(groupHeader);
      const groupItems = document.createElement("ul");
      groupItems.classList.add("group-items");
      group.forEach((instance) => {
        const groupItem = document.createElement("li");
        const componentNameContainer = document.createElement("div");
        componentNameContainer.classList.add("component-name-container");
        componentNameContainer.style.display = "flex";
        componentNameContainer.style.alignItems = "right";
        const itemIcon = createIcon(instance.type);
        componentNameContainer.insertBefore(itemIcon, componentNameContainer.firstChild);
        itemIcon.addEventListener("click", (e) => {
          e.stopPropagation();
          parent.postMessage(
            {
              pluginMessage: {
                type: "scroll-to-node",
                nodeId: instance.nodeId
              }
            },
            "*"
          );
        });
        itemIcon.addEventListener("mouseenter", () => {
          showPopover(itemIcon, instance);
        });
        const nameLink = document.createElement("a");
        nameLink.href = "#";
        nameLink.classList.add("component-link");
        nameLink.textContent = instance.name || "\u0411\u0435\u0437 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F";
        nameLink.addEventListener("click", (e) => {
          e.preventDefault();
          parent.postMessage(
            {
              pluginMessage: {
                type: "scroll-to-node",
                nodeId: instance.nodeId
                // Передаем nodeId инстанса
              }
            },
            "*"
          );
        });
        componentNameContainer.appendChild(nameLink);
        if (instance.parentName) {
          const parentName = document.createElement("span");
          parentName.classList.add("parent-component-name");
          parentName.textContent = "in " + instance.parentName;
          componentNameContainer.appendChild(parentName);
        }
        if (instance.hidden) {
          const hiddenLabel = document.createElement("span");
          hiddenLabel.classList.add("hidden-label");
          hiddenLabel.textContent = "hidden";
          componentNameContainer.appendChild(hiddenLabel);
        }
        if (instance.color) {
          groupItem.appendChild(componentNameContainer);
          if (instance.fill) {
            const fillContainer = document.createElement("div");
            fillContainer.style.display = "flex";
            fillContainer.style.alignItems = "center";
            fillContainer.style.marginTop = "0px";
            fillContainer.style.marginLeft = "0px";
            fillContainer.style.marginBottom = "4px";
            const fillSwatch = document.createElement("div");
            fillSwatch.style.width = "16px";
            fillSwatch.style.height = "16px";
            fillSwatch.style.backgroundColor = instance.fill;
            if (instance.fill_collection_name === "2" || instance.fill_collection_name === "Color Styles") {
              fillSwatch.style.borderRadius = "999px";
            } else {
              fillSwatch.style.borderRadius = "4px";
            }
            fillSwatch.style.marginRight = "4px";
            fillSwatch.style.marginLeft = "00px";
            fillSwatch.style.border = "1px solid #ddd";
            const fillInfo = document.createElement("div");
            fillInfo.style.display = "flex";
            fillInfo.style.flexDirection = "row";
            fillInfo.style.gap = "4px";
            fillInfo.style.justifyContent = "space-between";
            fillInfo.style.width = "100%";
            groupItem.appendChild(componentNameContainer);
            const varInfo = document.createElement("span");
            const fillType = document.createElement("span");
            fillType.textContent = "Fill";
            fillType.style.color = "var(--text-light-color)";
            fillType.style.fontWeight = "300";
            fillType.style.marginLeft = "auto";
            fillType.style.fontSize = "var(--font-small)";
            const collectionName = document.createElement("span");
            if (instance.fill_variable_name) {
              varInfo.textContent = instance.fill_variable_name;
              varInfo.style.color = "var(--text-light-color)";
              varInfo.style.fontWeight = "400";
              if (instance.fill_collection_name) {
                collectionName.textContent = ` from ${instance.fill_collection_name}`;
                collectionName.style.color = "var(--text-light-color)";
                collectionName.style.fontWeight = "300";
              }
            } else {
              varInfo.textContent = instance.fill;
              varInfo.style.color = "var(--text-light-color)";
              varInfo.style.fontWeight = "400";
            }
            fillInfo.appendChild(varInfo);
            fillInfo.appendChild(collectionName);
            fillInfo.appendChild(fillType);
            groupItem.appendChild(fillContainer);
          }
          if (instance.stroke) {
            const collectionName = document.createElement("span");
            const strokeContainer = document.createElement("div");
            strokeContainer.style.display = "flex";
            strokeContainer.style.alignItems = "center";
            strokeContainer.style.marginTop = "0px";
            strokeContainer.style.marginLeft = "0px";
            strokeContainer.style.marginBottom = "4px";
            const strokeSwatch = document.createElement("div");
            strokeSwatch.style.width = "16px";
            strokeSwatch.style.height = "16px";
            strokeSwatch.style.backgroundColor = instance.stroke;
            if (instance.stroke_collection_name === "2" || instance.stroke_collection_name === "Color Styles") {
              strokeSwatch.style.borderRadius = "999px";
            } else {
              strokeSwatch.style.borderRadius = "3px";
            }
            strokeSwatch.style.marginRight = "8px";
            strokeSwatch.style.border = "1px solid #ddd";
            const strokeInfo = document.createElement("div");
            strokeInfo.style.display = "flex";
            strokeInfo.style.flexDirection = "row";
            strokeInfo.style.gap = "4px";
            strokeInfo.style.justifyContent = "space-between";
            strokeInfo.style.width = "100%";
            const varInfo = document.createElement("span");
            if (instance.stroke_variable_name) {
              varInfo.textContent = instance.stroke_variable_name;
              varInfo.style.color = "var(--text-light-color)";
              varInfo.style.fontWeight = "400";
              if (instance.stroke_collection_name) {
                collectionName.textContent = ` from ${instance.stroke_collection_name}`;
                collectionName.style.color = "var(--text-light-color)";
                collectionName.style.fontWeight = "300";
              }
            } else {
              varInfo.textContent = instance.stroke;
              varInfo.style.color = "var(--text-light-color)";
              varInfo.style.fontWeight = "400";
            }
            const strokeType = document.createElement("span");
            strokeType.textContent = "Stroke";
            strokeType.style.color = "var(--text-light-color)";
            strokeType.style.fontWeight = "300";
            strokeType.style.marginLeft = "auto";
            strokeType.style.fontSize = "var(--font-small)";
            strokeInfo.appendChild(varInfo);
            strokeInfo.appendChild(collectionName);
            strokeInfo.appendChild(strokeType);
            groupItem.appendChild(strokeContainer);
          }
        }
        groupItems.appendChild(groupItem);
      });
      targetList.appendChild(groupItems);
      groupHeader.addEventListener("click", () => {
        groupItems.classList.toggle("expanded");
      });
    }
  };
  if (typeof window !== "undefined") {
    window.UIModules = window.UIModules || {};
    window.UIModules.displayColorsTab = displayColorsTab;
  }

  // src/ui/processAndDisplayColors.ts
  function processAndDisplayColors(colorsData, colorsStrokeData) {
    var _a;
    const showHiddenToggle = document.getElementById("showHiddenToggle");
    const showHidden = showHiddenToggle ? showHiddenToggle.checked : true;
    let fillFilteredCount = 0;
    let strokeFilteredCount = 0;
    const colorResultsList = document.getElementById("colorResultsList");
    const colorStrokeResultsList = document.getElementById("colorStrokeResultsList");
    const fillHeader = colorResultsList.previousElementSibling;
    const strokeHeader = colorStrokeResultsList.previousElementSibling;
    colorResultsList.innerHTML = "";
    colorStrokeResultsList.innerHTML = "";
    if (colorsData && colorsData.instances) {
      const groupedFillColors = {};
      let rawFillInstances = colorsData.instances;
      if (!showHidden) {
        rawFillInstances = rawFillInstances.filter((instance) => !instance.hidden);
      }
      rawFillInstances.forEach((instance) => {
        const hasFill = instance.fill && instance.fill !== "#MIXED";
        if (!hasFill) return;
        const wrongFill = instance.fill_collection_name !== "Component tokens" && instance.fill_collection_name !== "Service tokens" && instance.fill_collection_name !== "product colors";
        if (!wrongFill) return;
        fillFilteredCount++;
        const cleanInstance = __spreadValues({}, instance);
        delete cleanInstance.stroke;
        delete cleanInstance.stroke_variable_name;
        delete cleanInstance.stroke_collection_name;
        delete cleanInstance.stroke_collection_id;
        const colorIdentifier = cleanInstance.fill_variable_name ? cleanInstance.fill_variable_name : cleanInstance.fill;
        const collectionName = cleanInstance.fill_collection_name || "no_collection";
        const groupKey = `${colorIdentifier}-${collectionName}-${cleanInstance.type}`;
        if (!groupedFillColors[groupKey]) {
          groupedFillColors[groupKey] = [];
        }
        groupedFillColors[groupKey].push(cleanInstance);
      });
      const sortedFillGroupKeys = Object.keys(groupedFillColors).sort((a, b) => a.localeCompare(b));
      const sortedGroupedFillColors = {};
      sortedFillGroupKeys.forEach((key) => {
        sortedGroupedFillColors[key] = groupedFillColors[key];
      });
      if (fillFilteredCount > 0) {
        displayColorsTab(sortedGroupedFillColors, colorResultsList);
      } else {
        colorResultsList.innerHTML = "";
        if (fillHeader && fillHeader.classList.contains("section-header") && fillHeader.textContent === "Fill") {
          fillHeader.remove();
        }
      }
    } else {
      colorResultsList.innerHTML = "";
      if (fillHeader && fillHeader.classList.contains("section-header") && fillHeader.textContent === "Fill") {
        fillHeader.remove();
      }
    }
    if (colorsStrokeData && colorsStrokeData.instances) {
      const groupedStrokeColors = {};
      let rawStrokeInstances = colorsStrokeData.instances;
      if (!showHidden) {
        rawStrokeInstances = rawStrokeInstances.filter((instance) => !instance.hidden);
      }
      rawStrokeInstances.forEach((instance) => {
        const hasStroke = instance.stroke && instance.stroke !== "#MIXED";
        if (!hasStroke) return;
        const wrongStroke = instance.stroke_collection_name !== "Component tokens" && instance.stroke_collection_name !== "Service tokens" && instance.stroke_collection_name !== "product colors";
        if (!wrongStroke) return;
        strokeFilteredCount++;
        const cleanInstance = __spreadValues({}, instance);
        delete cleanInstance.fill;
        delete cleanInstance.fill_variable_name;
        delete cleanInstance.fill_collection_name;
        delete cleanInstance.fill_collection_id;
        const colorIdentifier = cleanInstance.stroke_variable_name ? cleanInstance.stroke_variable_name : cleanInstance.stroke;
        const collectionName = cleanInstance.stroke_collection_name || "no_collection";
        const groupKey = `${colorIdentifier}-${collectionName}-${cleanInstance.type}`;
        if (!groupedStrokeColors[groupKey]) {
          groupedStrokeColors[groupKey] = [];
        }
        groupedStrokeColors[groupKey].push(cleanInstance);
      });
      const sortedStrokeGroupKeys = Object.keys(groupedStrokeColors).sort((a, b) => a.localeCompare(b));
      const sortedGroupedStrokeColors = {};
      sortedStrokeGroupKeys.forEach((key) => {
        sortedGroupedStrokeColors[key] = groupedStrokeColors[key];
      });
      if (strokeFilteredCount > 0) {
        displayColorsTab(sortedGroupedStrokeColors, colorStrokeResultsList);
      } else {
        colorStrokeResultsList.innerHTML = "";
        if (strokeHeader && strokeHeader.classList.contains("section-header") && strokeHeader.textContent === "Stroke") {
          strokeHeader.remove();
        }
      }
    } else {
      colorStrokeResultsList.innerHTML = "";
      if (strokeHeader && strokeHeader.classList.contains("section-header") && strokeHeader.textContent === "Stroke") {
        strokeHeader.remove();
      }
    }
    const colorsTab = document.querySelector('[data-tab="colors"]');
    const totalColorIssues = fillFilteredCount + strokeFilteredCount;
    if (colorsTab) {
      if (totalColorIssues === 0) {
        colorsTab.classList.remove("colors");
        colorsTab.classList.add("disabled");
        colorsTab.textContent = `Colors (0)`;
        colorsTab.style.pointerEvents = "none";
      } else {
        colorsTab.classList.remove("disabled");
        colorsTab.classList.add("colors");
        colorsTab.textContent = `Colors (${totalColorIssues})`;
        colorsTab.style.pointerEvents = "auto";
      }
    }
    if (typeof window !== "undefined" && ((_a = window.UIModules) == null ? void 0 : _a.updateErrorsTabHeader)) {
      window.UIModules.updateErrorsTabHeader();
    }
  }
  if (typeof window !== "undefined") {
    window.UIModules = window.UIModules || {};
    window.UIModules.processAndDisplayColors = processAndDisplayColors;
  }
})();

"use strict";
(() => {
  // src/ui/displayDebugTab.ts
  function createDebugTree(data, searchTerm = "") {
    try {
      let hasMatchingChild = false;
      if (data === null || typeof data !== "object") {
        return createValueElement(data, searchTerm);
      }
      const details = document.createElement("details");
      const summary = document.createElement("summary");
      const container = document.createElement("div");
      container.style.paddingLeft = "20px";
      const isArray = Array.isArray(data);
      summary.textContent = isArray ? `Array [${data.length}]` : "Object";
      details.appendChild(summary);
      Object.entries(data).forEach(([key, value]) => {
        const line = document.createElement("div");
        line.style.marginBottom = "5px";
        const keySpan = document.createElement("span");
        keySpan.className = "key";
        keySpan.textContent = `${key}: `;
        keySpan.style.color = "#905";
        line.appendChild(keySpan);
        const valueContainer = createDebugTree(value, searchTerm);
        const matchesSearch = searchTerm && (key.toLowerCase().includes(searchTerm.toLowerCase()) || typeof value === "string" && value.toLowerCase().includes(searchTerm.toLowerCase()) || typeof value === "number" && String(value).includes(searchTerm));
        if (matchesSearch || valueContainer.hasMatch) {
          hasMatchingChild = true;
          details.open = true;
        }
        line.appendChild(valueContainer);
        container.appendChild(line);
      });
      details.appendChild(container);
      details.hasMatch = hasMatchingChild;
      return details;
    } catch (error) {
      console.error("\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u0438 \u0434\u0435\u0440\u0435\u0432\u0430 \u043E\u0442\u043B\u0430\u0434\u043A\u0438:", error);
      const errorElement = document.createElement("div");
      errorElement.style.color = "red";
      errorElement.textContent = `Error creating debug tree: ${error.message}`;
      return errorElement;
    }
  }
  function createValueElement(value, searchTerm = "") {
    const span = document.createElement("span");
    const stringValue = String(value);
    if (typeof value === "string") {
      span.className = "string";
      span.textContent = `"${value}"`;
      span.style.color = "#690";
    } else if (typeof value === "number") {
      span.className = "number";
      span.textContent = String(value);
      span.style.color = "#2f6f9f";
    } else if (typeof value === "boolean") {
      span.className = "boolean";
      span.textContent = String(value);
      span.style.color = "#2f6f9f";
    } else {
      span.textContent = stringValue;
    }
    if (searchTerm && stringValue.toLowerCase().includes(searchTerm.toLowerCase())) {
      span.className += " match";
      span.style.backgroundColor = "yellow";
      span.hasMatch = true;
    } else {
      span.hasMatch = false;
    }
    return span;
  }
  function displaySearchResults(results, searchTerm) {
    const searchResults = document.getElementById("searchResults");
    if (!searchResults) {
      console.error("\u042D\u043B\u0435\u043C\u0435\u043D\u0442 searchResults \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D");
      return;
    }
    searchResults.style.display = "block";
    const resultsDiv = document.getElementById("results");
    if (resultsDiv) {
      resultsDiv.style.display = "none";
    }
    const subTabs = document.getElementById("subTabs");
    if (subTabs) {
      subTabs.style.display = "flex";
    }
    searchResults.innerHTML = "";
    if (results.length === 0) {
      searchResults.innerHTML = "<p>No matches found</p>";
      return;
    }
    const resultList = document.createElement("ul");
    results.forEach((instance) => {
      const instanceData = instance;
      const li = document.createElement("li");
      const nameText = instanceData.name;
      const highlightedName = highlightText(nameText, searchTerm);
      const resultItem = document.createElement("div");
      resultItem.classList.add("search-result-item");
      resultItem.innerHTML = highlightedName;
      if (instanceData.description) {
        const description = document.createElement("span");
        description.classList.add("description-tag");
        description.innerHTML = " - " + highlightText(instanceData.description, searchTerm);
        resultItem.appendChild(description);
      }
      li.appendChild(resultItem);
      resultList.appendChild(li);
    });
    searchResults.appendChild(resultList);
  }
  function highlightText(text, searchTerm) {
    const regex = new RegExp(`(${searchTerm})`, "gi");
    return text.replace(regex, '<span class="highlight">$1</span>');
  }
  if (typeof window !== "undefined") {
    window.UIModules = window.UIModules || {};
    window.UIModules.createDebugTree = createDebugTree;
    window.UIModules.createValueElement = createValueElement;
    window.UIModules.displaySearchResults = displaySearchResults;
    window.UIModules.highlightText = highlightText;
  }
})();
</script></body>

</html>