# План рефакторинга плагина ConsistenSee на TypeScript

## 1. Цели

- **Перевести кодовую базу на TypeScript**: Повысить надежность и упростить разработку за счет статической типизации.
- **Разделить на модули**: Разбить монолитные файлы `code.js` и `ui.html` на небольшие, логически связанные модули.
- **Улучшить поддерживаемость**: Сделать код более читаемым, понятным и легким для модификации.
- **Сохранить функциональность**: Провести рефакторинг максимально безопасно, без потери текущих возможностей плагина.

## 2. Преимущества

- **Надежность**: TypeScript отловит множество ошибок на этапе компиляции, а не во время выполнения плагина в Figma.
- **Автодополнение и навигация**: Улучшенная поддержка в IDE (VS Code) благодаря типам из `@figma/plugin-typings`.
- **Масштабируемость**: Легко добавлять новые функции, не боясь сломать существующие, благодаря четкой структуре и типизации.
- **Читаемость**: Модульная структура и явные типы делают код самодокументируемым.

## 3. Предлагаемая структура файлов

```
ConsistenSee/
├── dist/                   # Папка для скомпилированных файлов, которые будет использовать Figma
│   ├── code.js
│   └── ui.html
│
├── src/                    # Исходный код
│   ├── main/               # Код для backend (code.js)
│   │   │   checkComponentUpdate.ts
│   │   │   processNodeComponent.ts
│   │   │   processNodeColors.ts
│   │   │   getDescription.ts
│   │   │   rgbToHex.ts
│   │   │   ...
│   │   ├── index.ts        # Главный файл backend, точка входа
│   │   └── types.ts        # Типы данных для backend
│   │
│   ├── ui/                 # Код для frontend (ui.html)
│   │   │   displayGroups.ts
│   │   │   showPopover.ts
│   │   │   setupEventListeners.ts
│   │   │   ...
│   │   ├── index.ts        # Главный файл frontend
│   │   ├── styles.css      # Стили для UI
│   │   └── types.ts        # Типы данных для UI
│
├── package.json
├── tsconfig.json
└── esbuild.config.js       # Скрипт для сборки проекта
```

## 4. Пошаговый план рефакторинга

Этот план построен по принципу **инкрементальных и безопасных изменений**. После каждого шага рекомендуется проверять работоспособность плагина.

### Этап 0: Подготовка и настройка сборки

1.  **Инициализировать `package.json`**:
    ```bash
    npm init -y
    ```
2.  **Установить зависимости**:
    ```bash
    # Основные зависимости
    npm install --save-dev typescript @figma/plugin-typings

    # Сборщик esbuild (быстрый и простой)
    npm install --save-dev esbuild
    ```
3.  **Создать `tsconfig.json`**:
    ```json
    {
      "compilerOptions": {
        "target": "es6",
        "lib": ["es6", "dom"],
        "strict": true,
        "moduleResolution": "node",
        "typeRoots": ["./node_modules/@types", "./node_modules/@figma"],
        "outDir": "./dist"
      }
    }
    ```
4.  **Настроить скрипт сборки `esbuild.config.js`**:

5.  **Добавить скрипт в `package.json`**:
    ```json
      "scripts": {
        "build": "node esbuild.config.js"
      }
    ```

### Этап 1: Безопасная миграция на TypeScript (без изменения логики)

1.  Создать новую структуру папок (`src`, `dist`).
2.  Скопировать `code.js` в `src/main/index.ts`.
3.  Скопировать `ui.html` в `src/ui/ui.html` 
4.  Запустить сборку: `npm run build`.
5.  Исправить первые очевидные ошибки типов, которые покажет TypeScript. На этом этапе допустимо использовать `any` для сложных объектов, чтобы сборка прошла успешно.
6.  **Проверка**: Загрузить плагин из папки `dist` в Figma и убедиться, что он работает так же, как и раньше.

### Этап 2: Модуляризация Backend (`src/main`)

На этом этапе мы будем выносить функции из `src/main/index.ts` в отдельные файлы. **Двигайтесь по одной функции за раз.**

1.  **Начать с простых утилит**:
    - Создать `src/main/utils/rgbToHex.ts`.
    - Перенести функцию `rgbToHex` и ее кэш `rgbToHexCache`.
    - Добавить типы для аргументов и возвращаемого значения.
    - Экспортировать функцию: `export function rgbToHex(...)`.
    - В `src/main/index.ts` импортировать ее: `import { rgbToHex } from './utils/rgbToHex';`.
    - **Собрать и протестировать**: `npm run build` и проверить в Figma, что цвета отображаются корректно.
2.  **Продолжить с более сложными функциями**:
    - Повторить процесс для `getDescription`, `isNodeOrParentHidden`, `processNodeColors`, `processNodeComponent`, `checkComponentUpdate` и т.д., размещая их в соответствующих папках (`utils`, `processing`, `api`).
    - При переносе функций, добавляйте строгую типизацию для аргументов, используя типы из `@figma/plugin-typings` (например, `node: SceneNode`, `mainComponent: ComponentNode`).
3.  **Типизировать объекты**:
    - Создать `src/shared/types.ts`.
    - Описать интерфейсы для данных, которыми обмениваются backend и frontend (например, `ComponentData`, `ColorData`, `PluginMessage`).
    - Использовать эти интерфейсы в сигнатурах функций.
4.  **Рефакторинг `figma.ui.onmessage`**:
    - Громоздкий `if/else if` можно разбить на отдельные функции-обработчики (например, `handleCheckAll`, `handleScrollToNode`), которые будут импортироваться и вызываться в `onmessage`.

### Этап 3: Модуляризация Frontend (`src/ui`)

Процесс аналогичен backend.

1.  **Вынести DOM-манипуляции**:
    - Перенести `displayGroups`, `showPopover`, `createDebugTree`, `createIcon` в папку `src/ui/dom/`.
    - Типизировать аргументы (например, `groupedData: Record<string, ComponentData[]>`).
2.  **Организовать обработчики событий**:
    - Сгруппировать все `addEventListener` в одной функции `setupEventListeners` в файле `src/ui/events/setupEventListeners.ts`.
    - Вызывать `setupEventListeners()` внутри `DOMContentLoaded`.
3.  **Рефакторинг `window.onmessage`**:
    - Аналогично backend, разбить на функции-обработчики (`handleAllResults`, `handleProgressUpdate`).
    - Использовать общие типы из `src/shared/types.ts` для проверки данных, приходящих от backend.

### Этап 4: Строгая типизация и чистка

1.  **Избавиться от `any`**: Пройти по всей кодовой базе и заменить `any` на конкретные типы или интерфейсы.
2.  **Проверить `strict: true`**: Убедиться, что все требования строгого режима TypeScript выполнены (проверка на `null`/`undefined`).
3.  **Код-ревью**: Перечитать новый код, чтобы убедиться в его логичности и чистоте.

## 5. Ключевые моменты для безопасности

- **Итеративность**: Не пытайтесь переписать все сразу. Переносите по одной функции, затем собирайте и тестируйте.
- **Система контроля версий**: Используйте Git. Делайте коммит после каждого успешного шага.
- **Тестирование**: После каждого значимого изменения (например, переноса функции) открывайте Figma, запускайте плагин и проверяйте, что функциональность не сломалась. Особенно тщательно тестируйте основной сценарий (`check-all`) и навигацию.
- **Сборка**: Регулярно запускайте `npm run build`, чтобы TypeScript сразу подсвечивал проблемы.